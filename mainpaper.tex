% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.21 of 2022/01/12
%
\documentclass[runningheads]{llncs}
%
\usepackage[T1]{fontenc}
% T1 fonts will be used to generate the final print and online PDFs,
% so please use T1 fonts in your manuscript whenever possible.
% Other font encondings may result in incorrect characters.
%
\usepackage{graphicx}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following two lines
% to display URLs in blue roman font according to Springer's eBook style:
%\usepackage{color}
%\renewcommand\UrlFont{\color{blue}\rmfamily}
%\urlstyle{rm}
%
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{amsmath, amssymb, amsthm}
% \usepackage{geometry}
% \geometry{a4paper, margin=2.5cm}
\usepackage{amsmath,amssymb,amsthm,mathtools}
\usepackage{enumitem}
% \usepackage{xspace}
\usepackage[most]{tcolorbox}
\tcbset{enhanced,breakable,sharp corners,colback=white}

% Theorem environments
% Theorem environments
\theoremstyle{definition}

\newtheorem{assumption}{Assumption}


% Custom commands
\newcommand{\BC}{\operatorname{BC}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\A}{\mathrm{BC}_k(R_q)}
\newcommand{\E}{\chi_e}
\newcommand{\Sset}{\chi_s}
\newcommand{\Inv}{^{\!-1}}
\newcommand{\DLL}{\text{DLL}}
\newcommand{\DLLR}{\DLL\text{-R}}
\newcommand{\DLLD}{\DLL\text{-D}}
\newcommand{\Hone}{\mathsf{H_1}}
\newcommand{\Htwo}{\mathsf{H_2}}
\newcommand{\Hthree}{\mathsf{H_3}}
\newcommand{\id}{\mathsf{id}}
\newcommand{\DLLCDH}{\DLL\text{-CDH}}
\newcommand{\DLLDDH}{\DLL\text{-DDH}}
\newcommand{\MSIS}{\text{MSIS}}
\newcommand{\xleftarrowdollar}{\xleftarrow{\$}}
\newcommand{\indcca}{\text{IND-CCA2}}
\newcommand{\indcpa}{\text{IND-CPA}}
\newcommand{\Enc}{\mathsf{Enc}}
\newcommand{\Dec}{\mathsf{Dec}}
\newcommand{\Encap}{\mathsf{Encap}}
\newcommand{\Decap}{\mathsf{Decap}}
\newcommand{\KeyGen}{\mathsf{KeyGen}}
\newcommand{\KDF}{\mathsf{KDF}}
\newcommand{\EncMsg}{\mathrm{EncMsg}}
\newcommand{\DecMsg}{\mathrm{DecMsg}}
\newcommand{\Rq}{\mathbb{Z}_q[x]/(x^n{+}1)}
\newcommand{\BCk}{\mathrm{BC}_k}
\newcommand{\BCk}{\mathrm{BC}_k}
\newcommand{\Acal}{\mathrm{BC}_k(R_q)}
\newcommand{\BC}{\BCk(R_q)}
\newcommand{\dist}{\mathcal{D}}
\newcommand{\getsS}{\xleftarrow{\$}\,}
\newcommand{\sendto}{\xrightarrow{\;\;\text{sends}\;\;}}
\newcommand{\G}{\mathsf{G}}
\newcommand{\Htag}{\mathsf{H'}}
\newcommand{\negl}{\text{negl}}
\newcommand{\Adv}{\mathrm{Adv}}
\newcommand{\Rq}{\mathbb{Z}_q[x]/(x^n{+}1)}
\newcommand{\Rk}{M_k(R_q)}
\newcommand{\rk}{R_q^{k^2}}
\newcommand{\vecop}{\mathrm{vec}}
\newcommand{\ot}{\otimes}
\usepackage{tikz}
\usetikzlibrary{arrows.meta, positioning}

\tikzset{
  box/.style={
    rectangle, draw, rounded corners, align=center,
    minimum width=6cm, minimum height=1.2cm
  },
  arrow/.style={-Latex, thick}
}
% Protocol environment
\newtcolorbox{protocolbox}[1]{
  title=Protocol: #1,
  colframe=black!10!gray,
  coltitle=black,
  fonttitle=\bfseries,
  boxed title style={colback=black!5!white}
}




\begin{document}
%
\title{Discrete Logarithm over Lattices (DLPL): A Structured Generalisation with Practical Post-Quantum Applications}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Djimnaibeye Sidoine \inst{1}
% \orcidID{0000-1111-2222-3333} 
% \and
% Djiby Sow\inst{2}
% \orcidID{1111-2222-3333-4444} 
}
%
\authorrunning{D. Sidoine}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{INSTA, Abeche, Chad \\
\email{dthekplus@gmail.com}\\
% \url{http://www.springer.com/gp/computer-science/lncs} \and
% UCAD, Dakar, Senegal\\
% \email{djiby.sow@ucad.edu.sn}}
%
}
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
The discrete logarithm problem (DL) in cyclic groups is broken by quantum computers. We propose a structured lattice-based generalization called the Discrete Logarithm Problem over Lattices (DLPL), set in commutative algebras of block-circulant matrices over NTT-friendly rings. We define search, decisional, and Diffie–Hellman variants, and prove that the search variant reduces to the well-studied Module-SIS problem. Leveraging this structure, we design compact and efficient key exchange, public-key encryption, and an IND-CCA2 key encapsulation mechanism. For practical post-quantum security, we provide concrete parameters, analyze resistance to known attacks, and demonstrate competitive performance compared to NIST finalists. Our work bridges classical algebraic intuition with lattice-based hardness, offering a new family of quantum-resistant cryptosystems
% Our security analysis demonstrates the viability of this approach for post-quantum cryptography.

\keywords{Discret logarithm problem \and Lattice based cryptography \and Module-SIS \and Bloc-circulant matrice \and Discret logarithm problem over Lattice .}
\end{abstract}
%
%
%
\section{Introduction}

% \subsection{Context}
Lattice-based cryptography has emerged as one of the most promising families for post-quantum security \cite{peikert2016decade}. This promise is exemplified by the recent standardization of schemes like Kyber \cite{bos2018crystals}, Dilithium \cite{ducas2018crystals}, and Falcon by NIST. The security of these primitives typically relies on the hardness of well-studied computational problems such as the \emph{Short Integer Solution} (SIS) \cite{ajtai1996generating} and \emph{Learning With Errors} (LWE) \cite{regev2009lattices}, along with their structured variants like Module-SIS and Module-LWE \cite{langlois2014lattice}.

In this landscape, the classical discrete logarithm (DL) problem on cyclic groups cannot withstand quantum attacks via Shor's algorithm \cite{shor1999polynomial}. It therefore becomes imperative to explore generalizations of this problem in quantum-resistant frameworks such as structured Euclidean lattices.

% \subsection{Motivation}
Although SIS and LWE problems offer strong security guarantees, their practical instantiations often suffer from significant key and signature expansion. Structured variants, exploiting polynomial rings like \( R_q = \mathbb{Z}_q[x]/(x^n+1) \), can substantially reduce these sizes thanks to algebraic compactness and operational efficiency offered by the Number Theoretic Transform (NTT) \cite{lyubashevsky2010ideal}.

However, most of these constructions remain based on "learning" (LWE) or "knapsack" (SIS) type problems. Our motivation is to enrich this landscape by proposing a structural generalization of the discrete logarithm problem in the lattice context, offering a natural algebraic alternative for designing cryptographic protocols such as key exchange and encapsulation mechanisms.

\subsection*{Contributions}
This article presents a generalization of the discrete logarithm problem in the context of structured Euclidean lattices, which we call \emph{Discrete Logarithm over Lattices} (DLPL). Our main contributions are:

\begin{itemize}
    \item \textbf{Formal definition of DLPL problems}: We introduce three variants—computational (DLPL-S), decisional (DLPL-D), and Diffie-Hellman (DLPL-DH)—in the algebra of block-circulant matrices over the ring \( R_q \).
    \item \textbf{Efficient algebraic framework}: We exploit the structure of block-circulant matrices to achieve compact representations and fast operations via NTT \cite{lyubashevsky2010ideal}.
    \item \textbf{Rigorous security reduction}: We demonstrate a probabilistic polynomial-time reduction from the DLPL-S problem to the well-studied Module-SIS problem \cite{lyubashevsky2013ideal}.
    \item \textbf{Complete security analysis}: We evaluate DLPL's resistance against generic and specialized attacks, and propose concrete parameters for post-quantum security.
    \item \textbf{Practical applications}: We design and analyze a DLPL-DH key exchange protocol, a public-key encryption scheme, and an IND-CCA2 KEM using the Fujisaki-Okamoto transformation.
\end{itemize}

\subsection*{Article Organization}
The rest of the article is organized as follows:
\begin{itemize}
    \item Section~\ref{sec:preliminaries} reviews necessary cryptographic notions, including SIS and Module-SIS problems, the ring \( R_q \), NTT, and block-circulant matrix algebra.
    \item Section~\ref{sec:DLPL} formally defines the DLPL problems and their variants.
    \item Section~\ref{sec:reduction} presents our main result: a reduction from DLPL-S to Module-SIS.
    \item Section~\ref{sec:analysis} analyzes the security of DLPL problems from various angles and compares our construction to other post-quantum schemes.
    \item Section 5 presents practical applications including key exchange, authenticated key exchange, public key encryption, and IND-CCA2 key Encapsulation Mechanisms.
    % \item Section~\ref{sec:conclusion} concludes and suggests future research directions.
\end{itemize}

\section{Cryptographic Preliminaries}
\label{sec:preliminaries}

\subsection{General Notations}
We use standard notations from lattice-based cryptography. Let \( n \) be a power of two, and \( q \) a prime number. We denote by \( \mathbb{Z}_q \) the ring of integers modulo \( q \), and define the quotient ring \( R_q = \mathbb{Z}_q[x]/(x^n+1) \). Elements of \( R_q \) are polynomials of degree at most \( n-1 \) with coefficients in \( \mathbb{Z}_q \).

For a probability distribution \( \mathcal{D} \), we write \( x \xleftarrow{\$} \mathcal{D} \) to indicate that \( x \) is sampled according to \( \mathcal{D} \). The notation \( U(\mathcal{X}) \) denotes the uniform distribution over set \( \mathcal{X} \).

The \( \ell_\infty \) norm of a polynomial \( a = \sum_{i=0}^{n-1} a_i x^i \in R_q \) is defined by \( \|a\|_\infty = \max_i |a_i| \), where coefficients are interpreted as integers in the interval \( (-q/2, q/2] \). The \( \ell_2 \) norm is defined by \( \|a\|_2 = \sqrt{\sum_{i=0}^{n-1} a_i^2} \).

\subsection{SIS and Module-SIS Problems}
The Short Integer Solution (SIS) and Module-SIS problems form the foundation for many post-quantum cryptographic constructions.

\begin{definition}[SIS Problem]
Let \( n \), \( m \), \( q \) be positive integers with \( q \) prime, and \( \beta > 0 \) a bound. Let \( \mathbf{A} \xleftarrow{\$} \mathbb{Z}_q^{n \times m} \) be a uniform matrix. The \( \mathrm{SIS}_{n,m,q,\beta} \) problem is to find a non-zero vector \( \mathbf{z} \in \mathbb{Z}^m \) such that:
\begin{itemize}
    \item \( \mathbf{A} \mathbf{z} \equiv \mathbf{0} \pmod{q} \)
    \item \( \|\mathbf{z}\|_2 \leq \beta \) (or \( \|\mathbf{z}\|_\infty \leq \beta \))
\end{itemize}
\end{definition}

\begin{definition}[Module-SIS Problem]
Let \( n \), \( k \), \( m \), \( q \) be positive integers. Let \( \mathbf{A} \xleftarrow{\$} R_q^{k \times m} \) be a uniform matrix of elements from \( R_q \). The \( \mathrm{MSIS}_{n,k,m,q,\beta} \) problem is to find a non-zero vector \( \mathbf{z} \in R_q^m \) such that:
\begin{itemize}
    \item \( \mathbf{A} \mathbf{z} \equiv \mathbf{0} \pmod{q} \)
    \item \( \|\mathbf{z}\|_2 \leq \beta \) (or \( \|\mathbf{z}\|_\infty \leq \beta \))
\end{itemize}
\end{definition}

The Module-SIS problem can be viewed as a structured version of SIS, where the matrix \( \mathbf{A} \) has elements in the ring \( R_q \) rather than \( \mathbb{Z}_q \). This structure allows for more compact representations and more efficient operations.

\subsection{Polynomial Rings and NTT}
The ring \( R_q = \mathbb{Z}_q[x]/(x^n+1) \) plays a central role in our construction. The choice of \( n \) as a power of two and the polynomial \( x^n+1 \) as modulus enables efficient use of the Number Theoretic Transform (NTT).

\begin{definition}[NTT on \( R_q \)]
Let \( \omega \) be a primitive \( 2n \)-th root of unity in \( \mathbb{Z}_q \) (if it exists). The NTT is a ring isomorphism:
\[
\mathrm{NTT}: R_q \rightarrow \mathbb{Z}_q^n
\]
that maps a polynomial \( a = \sum_{i=0}^{n-1} a_i x^i \) to the vector \( (\hat{a}_0, \ldots, \hat{a}_{n-1}) \) where:
\[
\hat{a}_j = \sum_{i=0}^{n-1} a_i \omega^{ij} \mod q
\]
\end{definition}

The NTT allows polynomial convolution (multiplication in \( R_q \)) to be performed in \( \mathcal{O}(n \log n) \) time via the fast transform algorithm, instead of the \( \mathcal{O}(n^2) \) time required by naive multiplication.

\subsection{Algebra of Block-Circulant Matrices}
Our construction relies on a generalization of the circulant structure to block matrices.

\begin{definition}[Block-Circulant Matrix]
Let \( k \) be a positive integer. A block-circulant matrix \( M \in \mathrm{BC}_k(R_q) \) is a \( k \times k \) block matrix where each block is an element of \( R_q \), satisfying the block-circulant property:
\[
M = 
\begin{bmatrix}
A_0 & A_1 & \cdots & A_{k-1} \\
A_{k-1} & A_0 & \cdots & A_{k-2} \\
\vdots & \vdots & \ddots & \vdots \\
A_1 & A_2 & \cdots & A_0
\end{bmatrix}
\]
for some \( A_0, A_1, \ldots, A_{k-1} \in R_q \).
\end{definition}

The set \( \mathrm{BC}_k(R_q) \) forms an \( R_q \)-algebra: it is closed under addition, multiplication, and contains the identity element. Multiplication in \( \mathrm{BC}_k(R_q) \) corresponds to block convolution.

\begin{proposition}[Isomorphism with \( R_q^k \)]
The map \( \phi: \mathrm{BC}_k(R_q) \rightarrow R_q^k \) that sends a block-circulant matrix to its first block row \( (A_0, A_1, \ldots, A_{k-1}) \) is an isomorphism of \( R_q \)-modules.
\end{proposition}

This isomorphism allows compact representation of a block-circulant matrix by only \( k \) elements of \( R_q \), rather than \( k^2 \) elements.

\begin{definition}[Distribution of Small Elements]
Let \( \chi \) be a distribution over \( R_q \) that produces polynomials with small coefficients. Typically, \( \chi \) can be:
\begin{itemize}
    \item A centered binomial distribution: \( a - b \) where \( a, b \xleftarrow{\$} \{0,1\}^n \)
    \item A discrete Gaussian distribution: \( D_{\mathbb{Z}^n, \sigma} \) with parameter \( \sigma \)
\end{itemize}
We extend \( \chi \) to \( \mathrm{BC}_k(R_q) \) by applying \( \chi \) independently to each block of the matrix.
\end{definition}

\begin{assumption}[Density of Invertibles]
Let \( \chi_s \) be the distribution of "small" elements of \( \mathrm{BC}_k(R_q) \). We assume that the probability that an element sampled according to \( \chi_s \) is invertible in \( \mathrm{BC}_k(R_q) \) is non-negligible. Formally, there exists a constant \( c > 0 \) such that:
\[
\Pr_{S \xleftarrow{\$} \chi_s}[S \text{ is invertible in } \mathrm{BC}_k(R_q)] \geq c
\]
\end{assumption}

This assumption, denoted Inv-BC, is crucial for our security reduction and is supported by empirical observations in common cyclotomic rings.

The following table summarizes the main parameters of our construction:
\begin{center}
\begin{tabular}{|c|l|}
\hline
Parameter & Description \\
\hline
\( n \) & Degree of polynomial modulus (\( x^n+1 \)), power of two \\
\( q \) & Prime modulus \\
\( k \) & Dimension of block-circulant matrices \\
\( \eta_s \) & Bound on secret coefficients \\
\( \eta_e \) & Bound on error coefficients \\
\hline
\end{tabular}
\end{center}
% \section*{Commutativity and closure of \texorpdfstring{$\Acal=\mathrm{BC}_k(R_q)k(R_q)$}{A = BCk(Rq)}}

% \paragraph{Setting.}
% Let \(R_q=\Rq\) be a commutative ring with unit. For a fixed positive integer \(k\),
% let \(\mathrm{BC}_k(R_q)k(R_q)\subset M_k(R_q)\) denote the set of all \(k\times k\) \emph{circulant}
% matrices with entries in \(R_q\), i.e., matrices determined by their first row
% \((b_0,b_1,\dots,b_{k-1})\in R_q^k\) so that the \((i,j)\)-entry is
% \(b_{(j-i)\bmod k}\).

% \begin{definition}[Shift matrix]
% Let \(P\in M_k(R_q)\) be the cyclic shift (permutation) matrix
% \[
%   P=\begin{pmatrix}
%   0 & 1 & 0 & \cdots & 0\\
%   0 & 0 & 1 & \cdots & 0\\
%   \vdots & & & \ddots & \vdots\\
%   0 & 0 & 0 & \cdots & 1\\
%   1 & 0 & 0 & \cdots & 0
%   \end{pmatrix},
%   \qquad P^k=I_k.
% \]
% For \(b(x)=\sum_{i=0}^{k-1} b_i x^i\in R_q[x]\), define \(b(P):=\sum_{i=0}^{k-1} b_i P^i\).
% \end{definition}

% \begin{lemma}[Polynomial model of circulants]\label{lem:poly-model}
% For any \(b_0,\dots,b_{k-1}\in R_q\), the matrix \(C=\sum_{i=0}^{k-1} b_i P^i\) is circulant
% with first row \((b_0,\dots,b_{k-1})\). Conversely, every circulant matrix arises uniquely
% this way.
% \end{lemma}

% \begin{proof}
% The \(j\)-th column of \(P^i\) is the cyclic shift of the \(j\)-th column of \(I_k\) by \(i\)
% positions. Hence the first row of \(b(P)\) is \((b_0,\dots,b_{k-1})\) and every subsequent
% row is a cyclic shift, i.e., \(b(P)\) is circulant. Conversely, a circulant matrix is completely
% determined by its first row; taking \(b_i\) equal to the first row entries yields the unique
% polynomial representation \(\sum b_i P^i\).
% \end{proof}

% \begin{proposition}[Ring isomorphism]\label{prop:isom}
% The map
% \[
%   \Phi:\; R_q[x]/(x^k-1)\ \longrightarrow\ \mathrm{BC}_k(R_q)k(R_q),\qquad
%   \Phi\big([b(x)]\big)=b(P),
% \]
% is a well-defined ring isomorphism (additive and multiplicative).
% \end{proposition}

% \begin{proof}
% \emph{Well-defined.} If \(b(x)\equiv c(x)\bmod (x^k-1)\), then \(b(x)-c(x)=(x^k-1)q(x)\) for some
% \(q(x)\). Since \(P^k=I_k\), we have \((x^k-1)\big|_{x=P}=P^k-I_k=0\), hence \(b(P)-c(P)=0\).
% Thus \(\Phi\) is well-defined.

% \emph{Homomorphism.} Linearity is clear:
% \(\Phi([b+c])=b(P)+c(P)\), \(\Phi([\lambda b])=\lambda\,b(P)\) for \(\lambda\in R_q\).
% For products, using \(P^iP^j=P^{i+j}\) and reduction modulo \(k\):
% \[
%   \Phi([b\cdot c])=\sum_{t=0}^{k-1}\Big(\sum_{i+j\equiv t\!\!\!\pmod{k}} b_i c_j\Big) P^t
%   = \Big(\sum_{i=0}^{k-1} b_i P^i\Big)\Big(\sum_{j=0}^{k-1} c_j P^j\Big)
%   = \Phi([b])\,\Phi([c]).
% \]

% \emph{Bijectivity.} By Lemma~\ref{lem:poly-model}, \(\Phi\) is surjective. Injectivity follows
% because if \(\Phi([b])=0\), then \(b(P)=0\); comparing first rows yields all coefficients zero
% in \(R_q\), i.e., \([b]=[0]\) in \(R_q[x]/(x^k-1)\).
% \end{proof}

% \begin{corollary}[Commutativity and closure under \(+\), \(\cdot\)]\label{cor:comm}
% Since \(R_q[x]/(x^k-1)\) is a commutative ring (polynomials over a commutative ring modulo a principal
% ideal), its isomorphic image \(\mathrm{BC}_k(R_q)k(R_q)\) is a commutative subring of \(M_k(R_q)\).
% In particular, \(\mathrm{BC}_k(R_q)k(R_q)\) is closed under addition and multiplication, and for all
% \(X,Y\in \mathrm{BC}_k(R_q)k(R_q)\) one has \(XY=YX\).
% \end{corollary}

% \begin{proof}
% Immediate from Proposition~\ref{prop:isom} since ring isomorphisms preserve the ring laws and
% commutativity.
% \end{proof}

% \begin{proposition}[Units and inversion in \(\mathrm{BC}_k(R_q)k(R_q)\)]\label{prop:units}
% An element \(C\in \mathrm{BC}_k(R_q)k(R_q)\) is invertible in \(M_k(R_q)\) with inverse again in \(\mathrm{BC}_k(R_q)k(R_q)\)
% if and only if its preimage \([b(x)]\in R_q[x]/(x^k-1)\) is a unit of the quotient ring.
% Equivalently, there exists \(c(x)\in R_q[x]\) such that
% \[
%   b(x)c(x)\equiv 1 \pmod{x^k-1},
% \]
% and then \(C^{-1}=\Phi([c(x)])\in \mathrm{BC}_k(R_q)k(R_q)\).
% \end{proposition}

% \begin{proof}
% Suppose \([b(x)]\) is a unit. Then \([b(x)][c(x)]=[1]\) for some \([c(x)]\).
% Applying \(\Phi\), we get \(\Phi([b])\Phi([c])=\Phi([1])=I_k\), i.e.,
% \(C^{-1}=\Phi([c])\in\mathrm{BC}_k(R_q)k(R_q)\). Conversely, if \(C\in\mathrm{BC}_k(R_q)k(R_q)\) is invertible in \(M_k(R_q)\)
% with inverse \(D\), the equality \(CD=I_k\) implies, by surjectivity of \(\Phi\), that
% \(D=\Phi([c])\) for some \([c]\) and hence \([b][c]=[1]\) in the quotient. Therefore \([b]\) is a unit.
% \end{proof}

% \begin{corollary}[Closure under inversion]\label{cor:inv}
% The group of units of \(\mathrm{BC}_k(R_q)k(R_q)\) is precisely the image under \(\Phi\) of the group of
% units of \(R_q[x]/(x^k-1)\). In particular, whenever \(C\in\mathrm{BC}_k(R_q)k(R_q)\) is invertible,
% its inverse \(C^{-1}\) lies in \(\mathrm{BC}_k(R_q)k(R_q)\).
% \end{corollary}

% \begin{remark}[Spectral viewpoint (optional)]
% When \(R_q\) contains a primitive \(k\)-th root of unity \(\omega\) with a suitable discrete
% Fourier transform (DFT) matrix \(F\) invertible over \(R_q\), every circulant \(C\) diagonalizes as
% \(C=F^{-1}\mathrm{diag}(b(1),b(\omega),\dots,b(\omega^{k-1}))F\), where \(b(x)\) is the associated
% polynomial. Then \(C\) is invertible iff all evaluations \(b(\omega^j)\) are units in \(R_q\).
% This provides an equivalent characterization consistent with Proposition~\ref{prop:units}.
% \end{remark}

% \paragraph{Conclusion.}
% By Proposition~\ref{prop:isom} and its corollaries, \(\Acal=\mathrm{BC}_k(R_q)k(R_q)\) is a commutative
% subring of \(M_k(R_q)\), closed under addition and multiplication; and by
% Proposition~\ref{prop:units} it is also closed under inversion (whenever the inverse exists).
\section{The discrete Logarithm Problem over Lattices (DLPL)}
\label{sec:DLPL}

\subsection{Algebraic Framework and Distributions}
\label{subsec:framework}

We define a generalization of the discrete logarithm problem in the context of structured Euclidean lattices. Our construction builds on the algebra of block-circulant matrices over the ring \( R_q = \mathbb{Z}_q[x]/(x^n + 1) \), where \( n \) is a power of two and \( q \) is a prime number. This choice enables efficient arithmetic via the Number Theoretic Transform (NTT).

Let \( \text{BC}_k(R_q) \) be the subalgebra of \( k \times k \) block-circulant matrices over \( R_q \). An element \( B \in \text{BC}_k(R_q) \) is compactly represented by its first block row \( (A_0, A_1, \ldots, A_{k-1}) \in R_q^k \), thanks to the isomorphism \( \phi : \text{BC}_k(R_q) \to R_q^k \).

We consider two probability distributions:
\begin{itemize}
    \item \( \chi_s \): a distribution over \( \text{BC}_k(R_q) \) producing matrices with small coefficients (e.g., centered binomial or discrete Gaussian), conditioned on invertibility.
    \item \( \chi_e \): a distribution over \( \text{BC}_k(R_q) \) producing error matrices with small norm.
\end{itemize}

We assume that the probability of drawing an invertible element from \( \chi_s \) is non-negligible (Assumption \textsf{Inv-BC}).

\subsection{The Search Discrete Logarithm Problem over Lattices (DLPL-S)}
\label{subsec:dll-r}

The computational variant of the DLPL problem is defined as follows:

\begin{definition}[DLPL-S]
Let \( A \stackrel{\$}{\leftarrow} R_q^{k\times k} \) be a public matrix. Sample an invertible secret matrix \( s_A \stackrel{\$}{\leftarrow} \chi_s \) and an error matrix \( e_A \stackrel{\$}{\leftarrow} \chi_e \). Compute the public value:
\[
t_A = (s_A A + e_A) s_A^{-1}.
\]
The \(\text{DLPL-S}\) problem is: given \( (A, t_A) \), recover a pair \( (\hat{s}_A, \hat{e}_A) \) such that:
\begin{enumerate}
    \item \( \hat{s}_A \in \text{BC}_k(R_q) \) is invertible,
    \item \( \hat{e}_A \in \text{BC}_k(R_q) \) is small,
    \item \( t_A = (\hat{s}_A A + \hat{e}_A) \hat{s}_A^{-1} \).
\end{enumerate}
\end{definition}

This can be rewritten as the linear equation:
\[
t_A s_A - s_A A = e_A.
\]

\subsection{The Decisional Discrete Logarithm Problem over Lattices (DLPL-D)}
\label{subsec:dll-d}

The decisional variant involves distinguishing a valid DLPL tuple from a uniform one:

\begin{definition}[DLPL-D]
Let \( A, t_A \) be generated as in DLPL-S. Let \( U \stackrel{\$}{\leftarrow} \Rk\) be a uniform matrix. The \(\text{DLPL-D}\) problem is: distinguish the pair \( (A, t_A) \) from \( (A, U) \).
\end{definition}

% This problem is analogous to the Decisional Diffie-Hellman (DDH) problem in the context of traditional discrete logarithms.

\subsection{The Diffie-Hellman Problem for DLPL (DLPL-DH)}
\label{subsec:dll-dh}

We also define an analogue of the Computational Diffie-Hellman problem:

\begin{definition}[DLPL-DH]
Let \( A, s_A, e_A, t_A \) be generated as in DLPL-S. Similarly, generate \( s_B, e_B, t_B \) for the same \( A \). The \(\text{DLPL-DH}\) problem is: given \( (A, t_A, t_B) \), compute:
\[
t_{AB} = (s_A t_B + e_A) s_A^{-1} = (s_B t_A + e_B) s_B^{-1} ,
\]
\end{definition}

This problem underlies the security of key exchange protocols built on the DLPL assumption.

\subsection{Hardness Assumptions}

We summarize the hardness assumptions introduced in this section:

\begin{itemize}
    \item \textbf{DLPL-S}: The search problem is hard for classical and quantum adversaries.
    \item \textbf{DLPL-D}: It is hard to distinguish valid instances from random ones.
    \item \textbf{DLPL-DH}: It is hard to compute a shared secret from public values.
\end{itemize}

These assumptions form the basis for constructing cryptographic primitives such as key encapsulation mechanisms and key exchange protocols.

% \section{Reduction from DLPL-S to Module-SIS}
% \label{sec:reduction}

% \subsection{Linearizing Isomorphism \(\Psi\)}
% \label{subsec:isomorphism}

% To establish the reduction to Module-SIS, we introduce a linearizing isomorphism that transforms the structural equations of \(\mathrm{BC}_k(R_q)\) into a linear system over \(\mathbb{Z}_q\).

% Let \(\phi : \mathrm{BC}_k(R_q) \to R_q^k\) be the isomorphism that sends a block-circulant matrix to its first block row. Let \(\gamma : R_q \to \mathbb{Z}_q^n\) be the map that sends a polynomial to its coefficient vector in the canonical basis.

% We define the composite isomorphism:
% \[
% \Psi = \gamma^{\oplus k} \circ \phi : \mathrm{BC}_k(R_q) \to \mathbb{Z}_q^{kn}
% \]

% This isomorphism preserves the algebraic structure: for any matrix \(T \in \mathrm{BC}_k(R_q)\), there exists a matrix \(\mathsf{M}_T \in \mathbb{Z}_q^{kn \times kn}\) such that:
% \[
% \Psi(TX) = \mathsf{M}_T \Psi(X) \quad \forall X \in \mathrm{BC}_k(R_q)
% \]

% Similarly, for \(A \in \mathrm{BC}_k(R_q)\), there exists \(\mathsf{M}_A \in \mathbb{Z}_q^{kn \times kn}\) such that:
% \[
% \Psi(XA) = \mathsf{M}_A \Psi(X) \quad \forall X \in \mathrm{BC}_k(R_q)
% \]

% \subsection{Construction of the SIS Matrix \(\mathsf{B}(A,T)\)}
% \label{subsec:construction}

% Consider the fundamental equation of DLPL-S:
% \[
% T = (SA + E)S^{-1} \quad \Longleftrightarrow \quad TS - SA = E
% \]

% Applying the isomorphism \(\Psi\) to both sides, we obtain:
% \[
% \Psi(TS) - \Psi(SA) = \Psi(E)
% \]

% Which can be rewritten, thanks to linearity properties:
% \[
% (\mathsf{M}_T - \mathsf{M}_A)\Psi(S) - \Psi(E) = 0 \pmod{q}
% \]

% We then define the SIS matrix:
% \[
% \mathsf{B}(A,T) = \left[ \mathsf{M}_T - \mathsf{M}_A \mid -\mathsf{I}_{kn} \right] \in \mathbb{Z}_q^{kn \times 2kn}
% \]

% And the unknown vector:
% \[
% x = \begin{bmatrix} \Psi(S) \\ \Psi(E) \end{bmatrix} \in \mathbb{Z}_q^{2kn}
% \]

% The equation becomes:
% \[
% \mathsf{B}(A,T) \cdot x \equiv 0 \pmod{q}
% \]

% \subsection{Norm Control}
% \label{subsec:norms}

% The reduction preserves the smallness of norms. If \(S\) and \(E\) are small according to distributions \(\chi_s\) and \(\chi_e\) with bounds \(\eta_s\) and \(\eta_e\), then:

% \begin{itemize}
%     \item For the \(\ell_\infty\) norm: \(\|x\|_\infty \leq \beta = \max(\eta_s, \eta_e)\)
%     \item For the \(\ell_2\) norm: \(\|x\|_2 \lesssim \sqrt{2kn} \cdot \beta\)
% \end{itemize}

% This preservation is crucial for the validity of the reduction to Module-SIS, which requires short solutions.


\section{Formal Reduction of \texorpdfstring{DLPL--S} to Module--SIS}
\label{sec:reduction}

We work over the ring $R_q=\Rq$ with $n$ a power of two and $q$ prime. For an integer $k\ge 1$, let $M_k(R_q)$ denote the set of $k\times k$ matrices over $R_q$.
We use the column-stacking vectorization map $\vecop: M_k(R_q)\to (R_q)^{k^2}$ and the Kronecker product $\ot$ over $R_q$.
For any matrix $X\in M_k(R_q)$, $\|X\|_\infty$ denotes the coefficient-wise $\ell_\infty$ norm, extended to vectors entrywise.

\begin{definition}[DLPL--S (linear form)]
Given $(A,t)\in M_k(R_q)^2$, a pair $(s,e)\in M_k(R_q)\times M_k(R_q)$ is a \emph{solution} if
\begin{equation}\label{eq:dlpls}
t\,s - s\,A \;=\; e \quad\text{in } M_k(R_q).
\end{equation}
In cryptographic instances one additionally requires that $s$ be invertible in $M_k(R_q)$ and that $s,e$ be \emph{small}, e.g.\ $\|s\|_\infty\le \sigma$ and $\|e\|_\infty\le \varepsilon$.
\end{definition}

\begin{definition}[Module--SIS over $R_q$]
Given $B\in R_q^{m\times d}$ and a bound $\beta>0$, the problem \textsf{Mod--SIS}$(B,\beta)$ asks for a nonzero $y\in (R_q)^d$ such that
\[
B\,y \equiv 0 \pmod q
\qquad\text{and}\qquad
\|y\|_\infty\le \beta.
\]
\end{definition}

\begin{lemma}[Kronecker identity over $R_q$]\label{lem:kronecker}
For any conformable $U,V,W$ over $R_q$,
\[
\vecop(U V W) \;=\; (W^\top \ot U)\,\vecop(V)\in (R_q)^{k^2},
\]
as established in the standard matrix analysis literature~\cite{horn1991topics,laub2005matrix}.
\end{lemma}

\begin{lemma}[Linearization]\label{lem:linearization}
Let $A,t,s,e\in M_k(R_q)$ be such that $t s - s A = e$. Then
\[
\Big(I_k\ot t - A^\top \ot I_k\Big)\,\vecop(s) \;-\; \vecop(e) \;=\; 0 \ \in (R_q)^{k^2},
\]
which is a direct application of the Kronecker product linearization~\cite{graham1981kronecker,vanloan2000ubiquitous}.
\end{lemma}

\begin{proof}
By Lemma~\ref{lem:kronecker}, $\vecop(t s)=(I_k\ot t)\vecop(s)$ and
$\vecop(s A)=(A^\top\ot I_k)\vecop(s)$. Subtract and move $\vecop(e)$ to the right-hand side.
\end{proof}


\begin{theorem}[DLPL--S $\rightarrow$ Module--SIS]\label{thm:reduction}
From any instance $(A,t)\in M_k(R_q)^2$, define
\[
M \;:=\; I_k\ot t \;-\; A^\top\ot I_k \in R_q^{\,k^2\times k^2},
\qquad
B \;:=\; \big[\, M \ \big|\  -I_{k^2}\,\big]\in R_q^{\,k^2\times 2k^2}.
\]
If $(s,e)$ satisfies $t s - s A = e$ with $\|s\|_\infty\le \sigma$ and $\|e\|_\infty\le \varepsilon$, then
\[
y^\star \;=\; \begin{bmatrix}\vecop(s)\\ \vecop(e)\end{bmatrix}\in (R_q)^{2k^2}\setminus\{0\}
\quad\text{satisfies}\quad
B\,y^\star \equiv 0 \pmod q,
\quad
\|y^\star\|_\infty \le \beta:=\max\{\sigma,\varepsilon\}.
\]
Hence \emph{every} DLPL--S witness induces a valid Module--SIS witness for $(B,\beta)$.
\end{theorem}
\begin{proof}
By Lemma~\ref{lem:linearization}, $M\,\vecop(s)-\vecop(e)=0$, which is equivalent to $B\,y^\star=0$ by construction.
The norm bound is immediate. Nonzeroness follows from $s\neq 0$ (in particular if $s$ is invertible).
\end{proof}

\begin{proposition}[Completeness (converse mapping)]\label{prop:converse}
If $y=\big[\vecop(s);\vecop(e)\big]\neq 0$ satisfies $B y=0$, then $t s - s A = e$ in $B_k(R_q)$.
\end{proposition}
\begin{proof}
The equality $B y=0$ is $M\,\vecop(s)=\vecop(e)$, i.e., $(I_k\ot t - A^\top\ot I_k)\vecop(s)=\vecop(e)$.
De-vectorization together with Lemma~\ref{lem:kronecker} yields $t s - s A = e$.
\end{proof}

\begin{remark}[Norm preservation and dimensions]
The mapping $(s,e)\mapsto y=[\vecop(s);\vecop(e)]$ preserves coefficient-wise bounds:
$\|y\|_\infty=\max\{\|s\|_\infty,\|e\|_\infty\}$.
The resulting Module--SIS instance has height $m=k^2$ and dimension $d=2k^2$ over the base ring $R_q$ (of degree $n$).
\end{remark}

\paragraph{Efficiency.}
Constructing $M=I_k\ot t - A^\top\ot I_k$ and $B=[M\mid -I_{k^2}]$ is polynomial in $(k,n,\log q)$.
The maps $\vecop$ and $\vecop^{-1}$ are linear-time in the matrix size. Therefore the reduction runs in polynomial time.

\subsection{Handling Invertibility}
\label{subsec:invertibility}

Requirement for \texorpdfstring{$s$}}
DLPL--S additionally requires that $s$ be invertible. While Theorem~\ref{thm:reduction} yields a \emph{linear} correspondence of witnesses, invertibility is not enforced by the homogeneous kernel condition $B y=0$ itself. We obtain a \emph{Las Vegas} reduction (expected polynomial time) by standard randomization and filtering:

\subsubsection{Randomization by Conjugation}
\label{subsubsec:conjugation}

Let \(U \in \mathrm{BC}_k(R_q)\) be a small invertible matrix (existing with non-negligible probability under the \textsf{Inv-BC} assumption). We define:
\[
A' = u^{-1}Au, \quad T' = u^{-1}tu
\]

Solving Module-SIS for \((A', t')\) yields \((s', e')\), and we recover the original solution via:
\[
s = Us', \quad e = ue'
\]

This technique preserves smallness and invertibility with probability \(\Omega(1)\).
\subsubsection{Randomized kernel smoothing.}
 Consider random invertible, short, block-diagonal $U=\mathrm{diag}(U_1,U_2)$ and random invertible $V$ (over $R_q$) that mix the two blocks so that $\ker(B')=V^{-1}\ker(B)$ for $B':=U B V$. A short solution $y'\in\ker(B')$ transforms to $y=V y'\in\ker(B)$, redistributing mass between the $s$- and $e$-components.
 \subsubsection{Filtering.}
Test whether the $s$-component of $y$ is invertible in $M_k(R_q)$ (polytime). If not, resample $U,V$ and repeat.

\noindent
Under the standard density-of-units assumption for short matrices over $R_q$ (units are non-negligibly dense; true in common CRT-local settings with prime $q$), the success probability per iteration is non-negligible, yielding expected polynomial time.
\subsubsection{ISIS Normalization}
\label{subsubsec:normalization}

An alternative is to add linear constraints to normalize \(\vecop(s)\). For example, fixing a specific coefficient of \(\vecop(s)\) to a known public value. This approach transforms the problem into an instance of Module-ISIS (Inhomogeneous SIS).

In practice, for random small \(S\) in \(\mathrm{BC}_k(R_q)\), the matrix \(S\) is invertible with high probability, making this technique effective.

\begin{center}
\begin{tikzpicture}[node distance=1.4cm]

% Nodes
\node[box] (dlpl) {DLPL--S instance : $(A, t)$};
\node[box, below=of dlpl] (relation) {Equation: $t s - s A = e$ \\ 
($s$ small and invertible, $e$ small)};
\node[box, below=of relation] (linear) {Vectorization + Kronecker product: \\
$(I_k \otimes t - A^\top \otimes I_k)\,\mathrm{vec}(s) - \mathrm{vec}(e) = 0$};
\node[box, below=of linear] (msis) {Module--SIS construction: \\
$M := I_k \otimes t - A^\top \otimes I_k$ \\
$B := [\, M \mid -I_{k^2}\,]$};
\node[box, below=of msis] (witness) {Witness: $y = \begin{bmatrix}\mathrm{vec}(s) \\ \mathrm{vec}(e)\end{bmatrix}$ \\
$B y = 0 \pmod{q},\;\; \|y\|_\infty \leq \beta$};
\node[box, below=of witness] (invertible) {If $s$ is invertible $\;\Rightarrow$ valid DLPL--S solution \\ 
Otherwise: randomization + filtering (Las Vegas reduction)};

% Arrows
\draw[arrow] (dlpl) -- (relation);
\draw[arrow] (relation) -- (linear);
\draw[arrow] (linear) -- (msis);
\draw[arrow] (msis) -- (witness);
\draw[arrow] (witness) -- (invertible);

\end{tikzpicture}

\end{center}
% \subsection{Main Reduction Theorem}
% \label{subsec:theorem}

% \begin{theorem}[Reduction from DLPL-S to Module-SIS]
% Under the \textsf{Inv-BC} assumption, there exists a probabilistic polynomial-time reduction from DLPL-S to Module-SIS. More precisely, for any adversary \(\mathrm{BC}_k(R_q)\) solving Module-SIS with advantage \(\epsilon\), we can construct an adversary \(\mathcal{B}\) solving DLPL-S with advantage \(\epsilon' \geq \epsilon/\text{poly}(n,k)\), where the Module-SIS parameters are:
% \[
% n_{\text{SIS}} = kn, \quad m_{\text{SIS}} = 2kn, \quad \beta_{\text{SIS}} = \max(\eta_s, \eta_e)
% \]
% \end{theorem}

% \begin{proof}[Proof Sketch]
% The reduction proceeds as follows:
% \begin{enumerate}
%     \item Given a DLPL-S instance \((A, T)\), construct \(\mathsf{B}(A,T)\) as in Section~\ref{subsec:construction}
%     \item Apply randomization by conjugation if necessary to ensure invertibility
%     \item Invoke the Module-SIS oracle to obtain a short vector \(x\)
%     \item Invert \(\Psi\) to obtain \((S, E)\)
%     \item Verify that \(S\) is invertible (if not, repeat with new randomization)
% \end{enumerate}
% Correctness follows directly from the linear construction, and efficiency is ensured by the \textsf{Inv-BC} assumption.
% \end{proof}

% \subsection{Dimensional Discussion and Tightness}
% \label{subsec:dimensions}

% The reduction has the following dimensional characteristics:

% \begin{itemize}
%     \item Unknown dimension: \(d = 2kn\)
%     \item Number of constraints: \(m = kn\)
%     \item SIS rate: \(d/m = 2\)
% \end{itemize}

% This reduction is \emph{tight} in the sense that the security loss is polynomial in parameters \(n\) and \(k\). Precise norm control allows preservation of the original security bounds.

% The block-circulant structure of \(\mathsf{M}_A\) and \(\mathsf{M}_T\) enables efficient implementation, exploiting NTT for fast computations. This property makes the reduction particularly suitable for practical applications in post-quantum cryptography.

% \subsection*{Handling the Invertibility Requirement for \texorpdfstring{$s$}}
% DLPL--S additionally requires that $s$ be invertible. While Theorem~\ref{thm:reduction} yields a \emph{linear} correspondence of witnesses, invertibility is not enforced by the homogeneous kernel condition $B y=0$ itself. We obtain a \emph{Las Vegas} reduction (expected polynomial time) by standard randomization and filtering:

% \begin{itemize}
%   \item \textbf{Randomized kernel smoothing.} Consider random invertible, short, block-diagonal $U=\mathrm{diag}(U_1,U_2)$ and random invertible $V$ (over $R_q$) that mix the two blocks so that $\ker(B')=V^{-1}\ker(B)$ for $B':=U B V$. A short solution $y'\in\ker(B')$ transforms to $y=V y'\in\ker(B)$, redistributing mass between the $s$- and $e$-components.
%   \item \textbf{Filtering.} Test whether the $s$-component of $y$ is invertible in $M_k(R_q)$ (polytime). If not, resample $U,V$ and repeat.
% \end{itemize}

% \noindent
% Under the standard density-of-units assumption for short matrices over $R_q$ (units are non-negligibly dense; true in common CRT-local settings with prime $q$), the success probability per iteration is non-negligible, yielding expected polynomial time.

\begin{theorem}[Formal Reduction]\label{thm:formal}
There exist polynomial-time transformations $\Enc$ and $\Dec$ such that for every DLPL--S instance $(A,t)$:
\begin{enumerate}
  \item $\Enc(A,t)=(B,\beta)$ with $B=[\,I_k\ot t - A^\top\ot I_k \mid -I_{k^2}\,]$.
  \item (\emph{Soundness}) If $(s,e)$ solves DLPL--S with $\|s\|_\infty\le\sigma$ and $\|e\|_\infty\le\varepsilon$, then $y=[\vecop(s);\vecop(e)]$ solves \textsf{Mod--SIS}$(B,\beta)$ with $\beta=\max\{\sigma,\varepsilon\}$.
  \item (\emph{Completeness, conditional}) If $y=[\vecop(s);\vecop(e)]$ solves \textsf{Mod--SIS}$(B,\beta)$ and $s$ is invertible, then $\Dec(y)=(s,e)$ solves DLPL--S.
  \item (\emph{Las Vegas reduction}) With randomized pre-/post-conditioning as above and unit-density assumption, a Module--SIS oracle yields, in expected polynomial time, a DLPL--S solution $(s,e)$ with $s$ invertible and $\|s\|_\infty,\|e\|_\infty\le \beta'$ for some polynomially related $\beta'$.
\end{enumerate}
\end{theorem}

\begin{proof}
Items (1)--(2) follow from Theorem~\ref{thm:reduction}; item (3) from Proposition~\ref{prop:converse}.
Item (4) is standard: random linear mixing preserves kernels while smoothing the witness distribution; filtering by invertibility succeeds with non-negligible probability per iteration, hence expected polynomial time.
\end{proof}




% \begin{remark}[Non-homogeneous view (Module-LWE form)]
% If one does not augment by $-I_{k^2}$, the equation becomes $M\,\vecop(s)=\vecop(e)$ with $e$ short, i.e., a linear system with short right-hand side, tightly related to a (module) LWE view. The homogeneous SIS encoding via $[M\mid -I]$ restores a pure kernel problem with a joint short witness $[\vecop(s);\vecop(e)]$.
% \end{remark}
% \subsection{Non-homogeneous view: a Module-LWE form}\label{subsec:nonhom-mlwe}

% Let $R_q=\Z_q[x]/(x^n{+}1)$, $A,t\in M_k(R_q)$, and set
% \begin{equation}\label{eq:M}
%   M \;:=\; I_k\otimes t \;-\; A^\top\otimes I_k \ \in R_q^{\,k^2\times k^2}.
% \end{equation}
% The linearized DLPL--S equation reads
% \begin{equation}\label{eq:nonhom-eq}
%   M\cdot \vecop(s)\;=\;\vecop(e)\qquad\text{in }(R_q)^{k^2},
% \end{equation}
% where $s,e\in M_k(R_q)$ and $e$ is \emph{short}. This is a \emph{non-homogeneous} linear system with a short right-hand side (RHS). In this section we explain a standard way to cast~\eqref{eq:nonhom-eq} into an \emph{LWE-shaped} problem over $R_q$ (module setting). The homogeneous SIS encoding via augmentation $[\,M\mid -I\,]$ is exact (cf.\ Theorem~\ref{thm:reduction}); the LWE view below is distributional and focuses on the typical cryptographic regime where the RHS is short and we may compress or randomize rows.

% \paragraph{Goal.}
% We wish to produce samples $(\mathsf A,\mathsf b)$ over $R_q$ such that
% \[
% \mathsf b \;=\; \mathsf A\cdot \vecop(s) \;+\; \varepsilon \quad\text{with}\quad
% \varepsilon\ \text{short and independent of }\vecop(s),
% \]
% i.e., a Module-LWE instance with secret $\vecop(s)$ and noise $\varepsilon$ derived from the original $\vecop(e)$.

% \subsubsection*{Left randomization / compression}
% Let $m\ge k^2$ and let $H\in R_q^{m\times k^2}$ be a (public) left-compressor.
% Typical choices are (i) \emph{short} masks (e.g., entries in $\{0,1,-1\}$) or
% (ii) uniform masks; both yield full row rank with high probability.\footnote{Short masks are often preferred as they keep noise magnitudes under control after multiplication.}
% Multiply~\eqref{eq:nonhom-eq} on the left by $H$:
% \begin{equation}\label{eq:compressed}
%   (H M)\cdot \vecop(s) \;=\; H\cdot \vecop(e).
% \end{equation}
% Introduce an \emph{independent} short perturbation $\eta\leftarrow \mathcal D_{\sigma_\eta}$ in $(R_q)^m$ and publish
% \begin{equation}\label{eq:lwe-samples}
%   \mathsf A \;:=\; H M \in R_q^{m\times k^2},
%   \qquad
%   \mathsf b \;:=\; H\cdot \vecop(e) \;+\; \eta \ \in (R_q)^m.
% \end{equation}
% Then, deterministically,
% \begin{equation}\label{eq:lwe-form}
%   \mathsf b \;=\; \mathsf A\cdot \vecop(s) \;+\; \underbrace{\big(H\cdot \vecop(e) + \eta \;-\; H\cdot \vecop(e)\big)}_{=\ \eta}.
% \end{equation}
% Thus $(\mathsf A,\mathsf b)$ are \emph{Module-LWE-shaped samples} with secret $\vecop(s)$ and noise $\varepsilon=\eta$ (independent of the secret). The role of $H$ is (i) to control the size and distribution of the effective noise when one wants to \emph{hide} the short RHS, and (ii) to offer many linear samples while keeping per-sample noise small.

% \begin{lemma}[Noise growth]\label{lem:noise-growth}
% Assume $\vecop(e)\leftarrow \mathcal D_{\sigma_e}^{k^2}$ is a (discrete) subgaussian over $R_q$ and
% $H$ has entries bounded by $h_{\max}$ coefficient-wise. Then $H\cdot \vecop(e)$ is subgaussian with parameter
% $\tilde\sigma \;\le\; h_{\max}\,\sqrt{k^2}\,\sigma_e$ per output coordinate. Consequently, the effective LWE noise
% $\varepsilon=\eta$ in~\eqref{eq:lwe-form} is distributed as $\mathcal D_{\sigma_\eta}$ (independent of $\vecop(s)$),
% and $\mathsf b= \mathsf A\vecop(s)+\varepsilon$ defines a Module-LWE instance of modulus $q$, dimension $k^2$, and $m$ samples.
% \end{lemma}

% \begin{proof}
% Each output coordinate is a sum of $k^2$ terms of the form $H_{i,j}\cdot (\vecop(e))_j$.
% Subgaussianity is preserved under bounded linear maps: the variance proxy scales by at most
% $h_{\max}^2 k^2$. The last claim is by construction of $\varepsilon$.
% \end{proof}

% \subsubsection*{Search vs.\ decision and indistinguishability}
% If $H$ is uniform over $R_q^{m\times k^2}$ and independent of $M$, then under mild genericity assumptions
% $H M$ is (close to) uniform over $R_q^{m\times k^2}$ conditioned on its rank. Hence the pair
% $(\mathsf A,\mathsf b)=(H M,\ H\vecop(e)+\eta)$ is computationally indistinguishable from standard \emph{Module-LWE samples}
% $(\mathbf A,\ \mathbf A\cdot \vecop(s)+\eta)$ with $\mathbf A\gets_u R_q^{m\times k^2}$, provided that the distribution of $H\vecop(e)$
% does not leak structure beyond the noise level.\footnote{If $H$ is short (e.g., ternary), $H M$ is not uniform; in this case,
% one may add a small uniform dither to $\mathsf b$ or rely on average-case MLWE hardness for non-uniform but high min-entropy $\mathsf A$.}
% Formally, we obtain:

% \begin{proposition}[Module-LWE form]\label{prop:mlwe-form}
% Let $M$ be defined by~\eqref{eq:M}, $\vecop(e)\leftarrow \mathcal D_{\sigma_e}^{k^2}$, $H\gets R_q^{m\times k^2}$ independent,
% and $\eta\leftarrow \mathcal D_{\sigma_\eta}^{m}$ independent. Then the distribution of samples
% \[
% (\mathsf A,\mathsf b) \;=\; \big(H M,\ H\cdot \vecop(e)+\eta\big)
% \]
% is computationally indistinguishable from Module-LWE samples $(\mathbf A,\ \mathbf A\cdot \vecop(s)+\eta)$ over $R_q$
% for a uniformly random secret $\vecop(s)$, up to the residual dependence on $M$’s image if any.
% \end{proposition}

% \noindent\emph{Discussion.}
% Equation~\eqref{eq:lwe-form} is exact with \emph{noise independent of the secret}.
% The short RHS $\vecop(e)$ is \emph{absorbed} by the left compression; the additional
% $\eta$ aligns the setting with the canonical LWE noise model and avoids degenerate (noise-free) equations.
% The standard search-to-decision reductions for Module-LWE can then be appealed to, under the usual parameter regimes.

% \subsubsection*{From the LWE form back to DLPL--S}
% A solver for Module-LWE on samples $(\mathsf A,\mathsf b)$ recovers $\vecop(s)$ with non-negligible probability,
% given enough samples $m=\Omega(k^2)$ and suitable noise levels $\sigma_\eta$.
% Knowing $\vecop(s)$, the original RHS is reconstructed as $\vecop(e)=M\vecop(s)$ from~\eqref{eq:nonhom-eq}.
% Thus, the non-homogeneous DLPL--S equation can be attacked via its Module-LWE form whenever the compressed samples are available.

% \paragraph{Relation to the homogeneous SIS augmentation.}
% The classical SIS embedding augments $M$ by $-I$ and places the \emph{entire} witness
% $[\vecop(s);\vecop(e)]$ in the kernel. The LWE form, instead, keeps the equation
% \emph{inhomogeneous} but compresses it to an overdetermined noisy system:
% \[
% \underbrace{\mathsf A}_{\text{public}} \cdot \underbrace{\vecop(s)}_{\text{secret}}
% \;+\; \underbrace{\varepsilon}_{\text{small}} \;\equiv\;
% \underbrace{\mathsf b}_{\text{public}} \pmod q.
% \]
% SIS and LWE perspectives are therefore complementary: the former yields a \emph{kernel} problem
% with a joint short witness; the latter yields a \emph{noisy linear} problem with a short RHS absorbed into the noise channel.

% \subsubsection*{Parameter guidance}
% Let $q$ be prime, $n$ a power of two, and let $k$ be the matrix dimension.
% Typical choices mirror Module-LWE practice:
% \begin{itemize}
%   \item \textbf{Modulus/noise.} Choose $q$ and $(\sigma_e,\sigma_\eta)$ so that
%   the effective noise standard deviation in each coordinate of $\mathsf b$
%   is well below $q$ (e.g., $\le q/(\tilde c\sqrt{\log q})$ for some constant $\tilde c$),
%   yet large enough to preclude trivial rounding attacks.
%   \item \textbf{Samples.} $m\ge c\cdot k^2$ (e.g., $c\in[2,4]$) suffices to overdetermine the system and enable MLWE decoding.
%   \item \textbf{Mask.} If $H$ is short with entries in $\{-1,0,1\}$ and row Hamming weight $w$,
%   then $\|H\cdot \vecop(e)\|$ behaves like a subgaussian with parameter $\approx \sqrt{w}\,\sigma_e$ (per row).
%   \item \textbf{Complexity.} Forming $\mathsf A=HM$ costs $\tilde O(mk^2)$ multiplications in $R_q$;
%   with NTT this is near-linear in $n$ per ring multiplication.
% \end{itemize}

% \subsubsection*{Edge cases and cautions}
% \begin{itemize}
%   \item If $e=0$, the system becomes noiseless and reveals $\vecop(s)$ from $\mathsf b=\mathsf A\vecop(s)$ if $\mathsf A$ has full column rank; this is \emph{easier} than MLWE and must be excluded by design.
%   \item If $H$ is public and short while $\eta=0$, then $\mathsf b=H\vecop(e)$ is itself short and may leak structure; adding $\eta$ (independent) restores the standard LWE noise model.
%   \item The LWE form is distributional: indistinguishability of $HM$ from uniform (or high min-entropy) is required to align with standard MLWE hardness. This typically holds when $M$ is not low-rank or structured pathologically and $H$ is chosen at random.
% \end{itemize}

% \paragraph{Takeaway.}
% Without augmentation, DLPL--S yields a \emph{linear system with short RHS}.
% By left compression and the addition of small independent noise, one obtains
% a bona fide \emph{Module-LWE instance} with secret $\vecop(s)$ and noise governed by
% $H\vecop(e)$ and $\eta$. This \emph{non-homogeneous} perspective complements the SIS kernel view
% and clarifies how DLPL--S aligns with standard Module-LWE hardness assumptions.


% \paragraph{Summary.}
% Vectorizing $t s - s A = e$ and augmenting by $-I$ produces a canonical Module--SIS instance whose short kernel witnesses are in one-to-one linear correspondence with DLPL--S witnesses, with norms preserved and a Las Vegas post-processing to ensure invertibility of $s$ as required by DLPL--S.

\subsection{Compression Using Block-Circulant Structure}
\label{subsec:compression}

The linearization presented in Section~\ref{sec:reduction} yields a Module-SIS instance of dimension $d = 2k^2$ over $R_q$. However, in the DLPL problem definition, the secret $s$ and error $e$ are assumed to be \emph{block-circulant matrices} in $\mathrm{BC}_k(R_q)$. This algebraic structure allows a significant compression of the linear system, reducing both the number of unknowns and the computational cost of the reduction.

\subsubsection{Compact Representation of Block-Circulant Matrices}
\label{subsubsec:compact-rep}

Let $k \geq 1$ and recall that a block-circulant matrix $S \in \mathrm{BC}_k(R_q)$ is uniquely determined by its first block row $(S_0, S_1, \dots, S_{k-1}) \in R_q^k$. There exists a fixed \emph{structure matrix}
\[
P_k \in R_q^{k^2 \times k}
\]
such that for any $S \in \mathrm{BC}_k(R_q)$ with first block row $\mathbf{s} = (S_0, \dots, S_{k-1})^\top$,
\[
\operatorname{vec}(S) = P_k \, \mathbf{s}.
\]
The matrix $P_k$ encodes the cyclic repetition pattern of blocks. Explicitly, if we index rows by $(i,j)$ with $i,j \in \{0,\dots,k-1\}$ (block row $i$, block column $j$), then the entry of $S$ in the $i$-th block row and $j$-th block column is $S_{(j-i) \bmod k}$. The matrix $P_k$ has a 1 in row $(i,j)$ and column $(j-i) \bmod k$, and zeros elsewhere.

\noindent\textbf{Example.} For $k=3$,
\[
P_3 = 
\begin{pmatrix}
1 & 0 & 0 \\
0 & 0 & 1 \\
0 & 1 & 0 \\
0 & 1 & 0 \\
1 & 0 & 0 \\
0 & 0 & 1 \\
0 & 0 & 1 \\
0 & 1 & 0 \\
1 & 0 & 0
\end{pmatrix}.
\]

\subsubsection{Compressed Linear System}
\label{subsubsec:compressed-linear}

Let $s, e \in \mathrm{BC}_k(R_q)$ be the unknown secret and error matrices. Write their first block rows as
\[
\mathbf{s} = (s_0, \dots, s_{k-1})^\top, \quad \mathbf{e} = (e_0, \dots, e_{k-1})^\top \in R_q^k.
\]
Then
\[
\operatorname{vec}(s) = P_k \mathbf{s}, \qquad \operatorname{vec}(e) = P_k \mathbf{e}.
\]
Substituting into the linearized equation $M \operatorname{vec}(s) = \operatorname{vec}(e)$ (Lemma~\ref{lem:linearization}) gives
\[
M P_k \mathbf{s} = P_k \mathbf{e}.
\]
Rearranging,
\[
M P_k \mathbf{s} - P_k \mathbf{e} = 0.
\]
Define the \emph{compressed unknown vector}
\[
x_{\text{circ}} = \begin{pmatrix} \mathbf{s} \\ \mathbf{e} \end{pmatrix} \in R_q^{2k},
\]
and the \emph{compressed matrix}
\[
N = \big[\, M P_k \mid -P_k \,\big] \in R_q^{\,k^2 \times 2k}.
\]
The equation becomes the homogeneous linear system
\[
N \, x_{\text{circ}} = 0.
\]

\subsubsection{Compressed Module-SIS Instance}
\label{subsubsec:compressed-msis}

Given a DLPL-S instance $(A,t)$ with the promise that a solution $(s,e)$ exists in $\mathrm{BC}_k(R_q)$, we construct a \emph{structured Module-SIS} instance as follows:

\begin{enumerate}
  \item Compute $M = I_k \otimes t - A^\top \otimes I_k \in R_q^{k^2 \times k^2}$.
  \item Form the compressed matrix $N = [M P_k \mid -P_k]$.
  \item Set the norm bound $\beta = \max\{\|s\|_\infty, \|e\|_\infty\}$ for the expected solution.
\end{enumerate}

The problem is: find a nonzero $x_{\text{circ}} \in R_q^{2k}$ such that
\[
N \, x_{\text{circ}} = 0 \pmod{q}, \qquad \|x_{\text{circ}}\|_\infty \leq \beta.
\]

\begin{proposition}[Compressed reduction]
\label{prop:compressed-reduction}
If $(s,e) \in \mathrm{BC}_k(R_q) \times \mathrm{BC}_k(R_q)$ satisfies $t s - s A = e$ with $\|s\|_\infty \leq \sigma$ and $\|e\|_\infty \leq \varepsilon$, then
\[
x_{\text{circ}} = (\mathbf{s}, \mathbf{e})^\top
\]
is a solution to the compressed Module-SIS instance $(N, \beta)$ with $\beta = \max\{\sigma,\varepsilon\}$.
\end{proposition}

\begin{proof}
Immediate from the construction and the definitions of $\mathbf{s}, \mathbf{e}$.
\end{proof}

Conversely, any short nonzero solution $x_{\text{circ}} = (\mathbf{s}, \mathbf{e})^\top$ of $N x_{\text{circ}} = 0$ yields block-circulant matrices $s = \operatorname{circ}(\mathbf{s})$, $e = \operatorname{circ}(\mathbf{e})$ satisfying $t s - s A = e$. If additionally $s$ is invertible in $\mathrm{BC}_k(R_q)$, then $(s,e)$ is a valid DLPL-S solution.

\subsubsection{Dimensionality Reduction and Efficiency}
\label{subsubsec:dim-reduction}

Without compression, the Module-SIS instance derived in Theorem~\ref{thm:reduction} has:
\begin{itemize}
  \item Matrix dimension: $B \in R_q^{k^2 \times 2k^2}$
  \item Unknown vector length: $2k^2$
\end{itemize}
With block-circulant compression, we obtain:
\begin{itemize}
  \item Matrix dimension: $N \in R_q^{k^2 \times 2k}$
  \item Unknown vector length: $2k$
\end{itemize}
This represents a reduction factor of $k$ in the number of unknowns. For typical parameters (e.g., $k=3$ or $k=4$), this compression significantly reduces the algebraic search space and can accelerate both the reduction itself and potential attack simulations.

\noindent\textbf{Computational cost.}
\begin{itemize}
  \item Constructing $P_k$ is deterministic and costless (precomputed).
  \item Computing $M P_k$ requires $k^2 \times k^2$ times $k^2 \times k$ multiplication over $R_q$, which is polynomial in $k$ and $n$.
  \item The resulting matrix $N$ has only $2k$ columns, making subsequent linear algebra (kernel computation, short-vector search) cheaper.
\end{itemize}

\subsubsection{Security Implications}
\label{subsubsec:security-impl}

The compressed system $N x_{\text{circ}} = 0$ is not a random Module-SIS instance: its structure reflects the block-circulant symmetry. However, the reduction from DLPL-S to Module-SIS in Theorem~\ref{thm:reduction} already accounts for this structure, because the original matrix $B = [M \mid -I_{k^2}]$ also inherits the algebraic relations induced by the block-circulant assumption.

One can view the compression as a \emph{change of basis} in the unknown space. Let
\[
Q = \begin{pmatrix} P_k & 0 \\ 0 & P_k \end{pmatrix} \in R_q^{2k^2 \times 2k}.
\]
Then $B Q = N$, and any solution $x_{\text{circ}}$ of $N x_{\text{circ}} = 0$ gives a solution $y = Q x_{\text{circ}}$ of $B y = 0$. The norm is preserved up to a constant factor because each column of $Q$ has exactly $k$ nonzero entries, each equal to 1.

Thus, finding a short vector in $\ker(N)$ is \emph{equivalent} to finding a short vector in $\ker(B)$ that lies in the image of $Q$—i.e., a solution corresponding to block-circulant matrices. This does not affect the asymptotic security of the reduction, because the Inv-BC assumption guarantees that a non-negligible fraction of short vectors in $\ker(B)$ arise from block-circulant secrets.

\subsubsection{Integration with the Las Vegas Reduction}
\label{subsubsec:integration-lasvegas}

The randomization and filtering techniques described in Section~\ref{subsec:invertibility} (conjugation, kernel smoothing) can be applied directly to the compressed system. One works with the $k^2 \times 2k$ matrix $N$ instead of the $k^2 \times 2k^2$ matrix $B$, gaining efficiency while preserving the same success probability for obtaining an invertible $s$.

\begin{theorem}[Compressed Las Vegas reduction]
\label{thm:compressed-lasvegas}
Under the Inv-BC assumption, there exists an expected polynomial-time reduction from DLPL-S (with block-circulant $s,e$) to the compressed Module-SIS problem $(N}, \beta)$. Moreover, any solution $x_{\text{circ}}$ with $s$-component invertible yields a valid DLPL-S solution.
\end{theorem}

\subsubsection{Practical Impact}
\label{subsubsec:practical-impact}

For concrete parameter choices (e.g., $n=256$, $k=3$), the compression reduces the unknown dimension from $2 \times 3^2 = 18$ ring elements to only 6 ring elements. This makes the linear system more tractable for both legitimate solvers and cryptanalysts, but the underlying hardness of Module-SIS remains unchanged because the compression is lossless with respect to the block-circulant constraint.

In cryptographic designs, this compression enables \emph{smaller key sizes} and \emph{faster operations} while maintaining the security reduction to a well-studied problem. The algebraic structure of $\mathrm{BC}_k(R_q)$ is thus exploited twice: for efficient arithmetic via NTT, and for dimensionality reduction in security arguments.
\section{Security Analysis}
\label{sec:analysis}

% \subsection{Plausibility of DLPL Assumptions}
% \label{subsec:plausibility}

% The analysis of the plausibility of DLPL-D and DLPL-S assumptions relies on their relationship with well-established problems in lattice-based cryptography.

% \subsubsection{Relation with LWE and Module-LWE}
% \label{subsubsec:relation-lwe}

% The algebraic structure of DLPL shows similarities with the Learning With Errors (LWE) problem \cite{regev2009lattices} and its structured variant Module-LWE \cite{langlois2014lattice}. However, several fundamental differences strengthen the plausibility of DLPL:

% \begin{itemize}
%     \item \textbf{Non-commutative structure}: Unlike classical LWE, the fundamental equation \( TS - SA = E \) involves a non-trivial commutation structure.
%     \item \textbf{Invertibility requirement}: The invertibility condition on \( S \) adds an additional algebraic constraint.
%     \item \textbf{Double secret}: The simultaneous presence of \( S \) and \( E \) as secrets increases attack complexity.
% \end{itemize}

The reduction to Module-SIS established in Section~\ref{sec:reduction} provides a strong argument for the hardness of DLPL-S, subject to the hardness of Module-SIS \cite{lyubashevsky2013ideal}.

\subsubsection{Analysis of the DLPL-D Assumption}
\label{subsubsec:analysis-dll-d}

For DLPL-D, the analysis is more subtle. In the structured case, the kernel of \( \mathsf{B}(A,T) \) contains a very short vector, while for a uniform pair \( (A,U) \), such a short vector typically does not exist. This distinction motivates treating DLPL-D as an independent assumption, analogous to the DDH problem in classical groups \cite{boneh1998decision}.

Preliminary numerical experiments on small instances confirm the difficulty of distinguishing valid instances from random ones, even for adversaries knowing the algebraic structure.

\subsection{Analysis of Generic Attacks}
\label{subsec:generic-attacks}

\subsubsection{Brute Force Attacks}
\label{subsubsec:brute-force}

Exhaustive search over the secret space is impractical. For typical parameters \( n = 256 \), \( k = 3 \), \( \eta_s = 3 \), the size of the secret space is approximately:
\[
(2\eta_s + 1)^{n \cdot k^2} \approx 7^{256 \cdot 9} \approx 2^{2300}
\]
which is well beyond classical or quantum computational capabilities \cite{grover1996fast}.

\subsubsection{Lattice Reduction Attacks}
\label{subsubsec:lattice-reduction}

The reduction to Module-SIS allows applying standard lattice reduction algorithms \cite{micciancio2012lattice,albrecht2017sage}. The complexity of the best known attacks against Module-SIS is given by:

\[
\text{Complexity} = 2^{O(n \cdot k \cdot \log q / \log \beta)}
\]

where \( \beta = \max(\eta_s, \eta_e) \). To ensure 128-bit security against lattice attacks, we recommend parameters satisfying:

\[
n \cdot k \cdot \frac{\log q}{\log \beta} \geq 256
\]

\subsubsection{Algebraic Attacks and Structure Exploitation}
\label{subsubsec:algebraic-attacks}

The block-circulant structure could potentially be exploited by algebraic attacks. However:

\begin{itemize}
    \item The linearization preserves algebraic structure but transforms it into a linear problem over \( \mathbb{Z}_q \).
    \item The randomization by conjugation introduced in Section~\ref{subsec:invertibility} neutralizes attacks exploiting specific symmetries.
    \item No efficient algebraic attack is known against structured variants of Module-SIS on cyclotomic rings \cite{lyubashevsky2013ideal}.
\end{itemize}

\subsubsection{Resistance to Quantum Attacks}
\label{subsubsec:quantum}

Known quantum algorithms, notably Grover's algorithm \cite{grover1996fast} and Hallgren's algorithm \cite{hallgren2010polynomial}, offer only quadratic speedup against SIS-type problems. Post-quantum security is therefore preserved with appropriate parameters \cite{bernstein2009introduction}.

Our construction compares favorably with other post-quantum schemes:

\begin{itemize}
    \item \textbf{vs Kyber} \cite{bos2018crystals}: Better compactness thanks to block-circulant structure
    \item \textbf{vs Saber} \cite{d2020saber}: Potentially more robust security foundation due to reduction to Module-SIS
    \item \textbf{vs NTRU} \cite{hoffstein1998ntru}: Different algebraic structure avoiding some known vulnerabilities
\end{itemize}

The security/efficiency trade-off is competitive with NIST PQC finalists \cite{alagic2022status}.

\section{Practical Application Examples}
Practical applications of our construction include:

\begin{itemize}
    \item \textbf{Key exchange protocols}: The Diffie-Hellman analogue (DLPL-DH) enables design of quantum-secure key exchange protocols, including an authenticated variant inspired by HMQV schemes~\cite{krawczyk2005hmqv}.
    \item \textbf{Encryption/decryption}: The structure naturally lends itself to efficient encryption/decryption schemes.
    \item \textbf{Encapsulation mechanisms}: The structure naturally supports construction of efficient Key Encapsulation Mechanisms (KEMs).
\end{itemize}

\subsection{DLPL-DH Key Exchange Protocol}
We present a \emph{Diffie-Hellman type scheme} adapted to Euclidean lattices in the commutative block-circulant algebra \(\mathrm{BC}_k(R_q)\). Similar to classical DH~\cite{diffie1976}, two parties (Alice, Bob) publish "headers" derived from ephemeral secrets through a \emph{conjugation} operation masked by noise: Alice sends \(t_A=(s_AA+e_A)s_A^{-1}\), Bob sends \(t_B=(s_BA+e_B)s_B^{-1}\), where \(A\in\Rk\) is public, \(s_A,s_B\) are invertible, and \(e_A,e_B\) are discrete errors. Thanks to the \emph{commutativity} of \(\mathrm{BC}_k(R_q)\), each party combines their local view and the received message to obtain the same value \(K=(s_As_B)A(s_As_B)^{-1} + \text{controlled noise}\), from which a shared key is derived via a KDF. The security intuition is: public views \((A,t_A,t_B)\) are indistinguishable from random under the \textsf{DLPL–DH} assumption in \(\mathrm{BC}_k(R_q)\), preventing an adversary from distinguishing or reconstructing \(K\) without knowing the secrets.

\subsubsection{Public Parameters}

We work over the negacyclic ring \(R_q=\Rq\) with \(n\) a power of two and \(q\) prime.
The algebra \(\mathrm{BC}_k(R_q)\) of block-circulant matrices 
is \emph{commutative} and closed for addition, multiplication, and inversion (when it exists).

\begin{itemize}[leftmargin=1.3em]
  \item \(n\): polynomial degree 
  % (power of \(2\), typically \(256\))
  \item \(q\): prime modulus
  % (typically \(\approx 2^{23}\))
  % \item \(k\): dimension of block-circulant matrices (typically \(2\)–\(4\))
  \item \(\chi_s,\chi_e\): distributions for secrets/errors 
  % (centered binomials)
  \item \(A \in R_q^{k\times k}\): public matrix
\end{itemize}

\paragraph{Validity assumptions.}
(i) Samples \(s\gets\chi_s\) are invertible and small in \(\mathrm{BC}_k(R_q)\) with high probability (or via rejection until invertible). (ii) The objects \(s,e\) live in \(\mathrm{BC}_k(R_q)\) and \(A , t \in  \Rk\).

\subsubsection{Protocol Description}
\hspace{2}
\begin{protocolbox}{DLPL–DH on \(\mathrm{BC}_k(R_q)\)}
\textbf{Public inputs} \(\mathsf{params}=(n,q,k,\chi_s,\chi_e,A)\).

\medskip
\textbf{Exchange phase.}
\begin{enumerate}[leftmargin=1.3em]
  \item \textbf{Alice}: samples \((s_A,e_A)\gets(\chi_s,\chi_e)\) with \(s_A\) invertible;\\
        computes \(t_A \coloneqq (s_A A + e_A)s_A\Inv = s_A A s_A\Inv + e_A s_A\Inv\).
        \hfill\(A \sendto B:~t_A\)
  \item \textbf{Bob}: samples \((s_B,e_B)\gets(\chi_s,\chi_e)\) with \(s_B\) invertible;\\
        computes \(t_B \coloneqq (s_B A + e_B)s_B\Inv = s_B A s_B\Inv + e_B s_B\Inv\).
        \hfill\(B \sendto A:~t_B\)
\end{enumerate}

\textbf{Key derivation phase.}
\begin{enumerate}[leftmargin=1.3em]
  \item \textbf{Alice}: \(K_A \coloneqq (s_A t_B + e_A)s_A\Inv\).
  \item \textbf{Bob}: \(K_B \coloneqq (s_B t_A + e_B)s_B\Inv\).
\end{enumerate}

\textbf{Output.} Both parties derive a key \( \mathsf{ss} = \mathsf{KDF}(K) \) (e.g., via \(\mathrm{SHAKE}\)) from \(K\in R_q^{k\times k}\).
\end{protocolbox}

\subsubsection{Correctness}

\begin{proofsketch}
By substituting \(t_A,t_B\) and expanding:
\[
\begin{aligned}
K_A
  &= (s_A (s_B A s_B\Inv + e_B s_B\Inv) + e_A) s_A\Inv \\
  &= s_A s_B A s_B\Inv s_A\Inv + s_A e_B s_B\Inv s_A\Inv + e_A s_A\Inv.
\end{aligned}
\]
Since \(\mathrm{BC}_k(R_q)\) is commutative, \(s_A s_B = s_B s_A\) and \(s_B\Inv s_A\Inv = (s_A s_B)\Inv\).
Moreover, we can inject \(I = s_B s_B\Inv\) in the last term:
\[
e_A s_A\Inv = (e_A s_B) (s_A s_B)\Inv.
\]
Similarly, \(s_A e_B s_B\Inv s_A\Inv = (s_A e_B)(s_A s_B)\Inv\).
Thus
\[
K_A \;=\; (s_A s_B) A (s_A s_B)\Inv \;+\; (s_A e_B + e_A s_B)\,(s_A s_B)\Inv.
\]
By symmetry, we obtain
\[
K_B \;=\; (s_B s_A) A (s_B s_A)\Inv \;+\; (s_B e_A + e_B s_A)\,(s_B s_A)\Inv,
\]
which coincides term by term with \(K_A\) since \(s_A s_B=s_B s_A\).
Therefore \(K_A = K_B\).
\end{proofsketch}

\subsection{Authenticated DLPL-DH Key Exchange Protocol}
\label{subsec:auth-dll-dh}
We now present an \emph{authenticated} version of the DLPL-DH key exchange protocol that provides mutual authentication and forward secrecy, inspired by HMQV-style protocols~\cite{krawczyk2005hmqv}. This protocol combines long-term static keys with ephemeral keys to achieve strong security guarantees against active adversaries.

\subsubsection{Authentication Framework}

The authenticated protocol builds on the following components:

\begin{itemize}
    \item \textbf{Long-term keys}: Each party maintains a static key pair $(sk_i, pk_i)$ for authentication
    \item \textbf{Ephemeral keys}: Each session generates fresh ephemeral keys for forward secrecy
    \item \textbf{Authentication tags}: Cryptographic hashes binding ephemeral values to long-term identities
    \item \textbf{Key confirmation}: Mutual verification that both parties have computed the same shared secret
\end{itemize}

\subsubsection{Long-Term Key Generation}

Each party $P_i$ generates their long-term authentication keys as follows:

\begin{protocolbox}{Long-Term Key Generation}
\textbf{KeyGen}($1^\lambda$):
\begin{enumerate}[leftmargin=1.3em]
    \item Sample $s_i \gets \chi_s$ until invertible in $\mathrm{BC}_k(R_q)$
    \item Sample $e_i \gets \chi_e$ 
    \item Compute $t_i = (s_i A + e_i)s_i^{-1}$
    \item Output: $pk_i = (A, t_i)$, $sk_i = s_i$
\end{enumerate}
\end{protocolbox}
\subsubsection{Authenticated Protocol Definition}
\hspace{2}
\begin{protocolbox}{Authenticated DLPL-DH Key Exchange}
\textbf{Participants}: Alice ($A$) and Bob ($B$) with long-term keys $(pk_A, sk_A)$, $(pk_B, sk_B)$

\textbf{Public parameters}: $\mathsf{params} = (n, q, k, \chi_s, \chi_e, A)$

\textbf{Cryptographic functions}: 
$H_1: \{0,1\}^* \to R_q$, $ H_2, H_3: \{0,1\}^* \to \{0,1\}^\lambda$, $\KDF: \{0,1\}^* \to \{0,1\}^\lambda$

\medskip
\textbf{Round 1: Ephemeral Key Exchange}
\begin{enumerate}[leftmargin=1.3em]
    \item \textbf{Alice}:
    \begin{itemize}
        \item Sample $r_A \gets \chi_s$ (invertible), $d_A \gets \chi_e$
        \item Compute $y_A = (r_A A + d_A)(r_A)^{-1}$
        \item Send $(pk_A, y_A)$ to Bob
    \end{itemize}
    
    \item \textbf{Bob}:
    \begin{itemize}
        \item Sample $r_B \gets \chi_s$ (invertible), $d_B \gets \chi_e$
        \item Compute $y_B = (r_B A + d_B)(r_B)^{-1}$
        \item Send $(pk_B, y_B)$ to Alice
    \end{itemize}
\end{enumerate}

\textbf{Round 2: Authentication and Key Confirmation}
\begin{enumerate}[leftmargin=1.3em, start=3]
    \item \textbf{Alice}:
    \begin{itemize}
        \item Compute ephemeral component: $K_A^e = (r_A t_B + d_A)(r_A)^{-1}$
        \item Compute static component: $K_A^s = (s_A t^e_B + e_A)s_A^{-1}$
         \item Compute  tag: $\alpha = H_1(0,id_A, id_B, y_A, y_B)$
          \item Compute  tag: $\beta = H_1(1,id_B,id_A,y_B,y_A) $
        \item Combine: $K_A = \alpha K_A^e + \beta K_A^s$
        \item Compute authentication tag: $\sigma_A = H_2(id_A, id_B, y_A, y_B, K_A)$
        \item Send $\sigma_A$ to Bob
    \end{itemize}
    
    \item \textbf{Bob}:
    \begin{itemize}
        \item Compute ephemeral component: $K_B^e = (r_B t_A + d_B)(r_B)^{-1}$
        \item Compute static component: $K_B^s = (s_B t^e_A + e_B)s_B^{-1}$
          \item Compute  tag: $\alpha = H_1(0,id_A, id_B, y_A, y_B)$
          \item Compute  tag: $\beta = H_1(1,id_B,id_A,y_B,y_A) 
        \item Combine: $K_B = \beta K_B^e + \alpha K_B^s$
        \item Verify $\sigma_A \stackrel{?}{=} H_2(id_A, id_B, y_A, y_B, K_B)$
        \item If verification fails: abort
        \item Compute response tag: $\sigma_B = H_2(id_B, id_A, y_B, y_A, K_B)$
        \item Send $\sigma_B$ to Alice
    \end{itemize}
    
    \item \textbf{Alice}:
    \begin{itemize}
        \item Verify $\sigma_B \stackrel{?}{=} H_2(id_B, id_A, y_B, y_A, K_A)$
        \item If verification fails: abort
    \end{itemize}
\end{enumerate}

\textbf{Final Key Derivation}
\begin{enumerate}[leftmargin=1.3em, start=6]
    \item Both parties compute: $\mathsf{ss} = \KDF(K_A \parallel \sigma_A \parallel \sigma_B)$
    \item Optional key confirmation: exchange $\H_3(\mathsf{ss})$
    \item Output: shared secret $\mathsf{ss}$
\end{enumerate}
\end{protocolbox}

\subsubsection{Correctness}

% \paragraph{Algebraic setting.}
% Let the base ring be \(R_q=\mathbb{Z}_q[x]/(x^n+1)\) (all arithmetic modulo \(q\)), and let
% \(\mathrm{BC}_k(R_q)\) denote the commutative block-circulant algebra of
% \(k\times k\) blocks over \(R_q\).
% We write multiplication multiplicatively and addition additively.
% The algebra \(\mathrm{BC}_k(R_q)\) is closed under addition, multiplication, and inversion
% (whenever the inverse exists). For any invertible \(X\in\mathrm{BC}_k(R_q)\):
% \((XY)^{-1}=Y^{-1}X^{-1}\).
% Conjugation distributes over addition: \(S(X+Y)S^{-1}=SXS^{-1}+SYS^{-1}\).

\paragraph{Public parameter and keys.}
Fix a public element \(A\in\Rk\).
Each party has a static (long-term) secret \(s\in\mathrm{BC}_k(R_q)^\times\) (invertible) and an
error \(e\in\mathrm{BC}_k(R_q)\), with static header
\[
  t=(sA+e)s^{-1}\in\Rk.
\]
In each session, each party also samples an ephemeral secret \(r\in\mathrm{BC}_k(R_q)^\times\)
and error \(d\in\Rk\), with ephemeral header
\[
  y=(rA+d)(r)^{-1}\in\Rk.
\]
We assume re-sampling until invertibility for all secrets.

\paragraph{Authenticated aggregation.}
Let \(\alpha,\beta\) be \emph{scalars} of \(R_q\)  derived from an agreed transcript via a hash/expansion function;
hence they commute with all elements of \(\Rk\).
Define the local key material on Alice's side by
\[
  K_A \;=\; \alpha\,K_A^{e} + \beta\,K_A^{s},
\]
where
\[
  K_A^{e}=(r_At_B+d_A)(d_A)^{-1},
  \qquad
  K_A^{s}=(s_A\,y_B+e_A)s_A^{-1}.
\]
Similarly, Bob computes
\[
  K_B \;=\; \beta\,K_B^{e} + \alpha\,K_B^{s},
\]
with
\[
  K_B^{e}=(r_Bt_A+d_B)(r_B)^{-1},
  \qquad
  K_B^{s}=(s_B\,y_A+e_B)s_B^{-1}.
\]
We now prove \(K_A=K_B\) exactly in \(\Rk\).

% ----------------
% Lemma 1
% ----------------
\begin{lemma}[Ephemeral--Static equality]\label{lem:ee}
With the above notation,
\(
  K_A^{e} = K_B^{s}.
\)
\end{lemma}

\begin{proof}
We expand \( K_A^e \):
\[
\begin{aligned}
K_A^e &= (r_A t_B + d_A)(r_A)^{-1} \\
&= \left[r_A (s_B A + e_B)s_B^{-1} + d_A\right](r_A)^{-1} \\
&= r_A s_B A s_B^{-1}(r_A)^{-1} + r_A e_B s_B^{-1}(r_A)^{-1} + d_A(r_A)^{-1}
\end{aligned}
\]

Using commutativity and conjugation properties:
\[
\begin{aligned}
K_A^e &= (r_A s_B) A (r_A s_B)^{-1} + (r_A e_B)(r_A s_B)^{-1} + (d_A s_B)(r_A s_B)^{-1}
\end{aligned}
\]

Now expand \( K_B^s \):
\[
\begin{aligned}
K_B^s &= (s_B y_A + e_B)s_B^{-1} \\
&= \left[s_B(r_A A + d_A)(r_A)^{-1} + e_B\right]s_B^{-1} \\
&= s_B r_A A (r_A)^{-1} s_B^{-1} + s_B d_A (r_A)^{-1} s_B^{-1} + e_B s_B^{-1}
\end{aligned}
\]

Using commutativity:
\[
\begin{aligned}
K_B^s &= (r_A s_B) A (r_A s_B)^{-1} + (s_B d_A)(r_A s_B)^{-1} + (e_B r_A)(r_A s_B)^{-1}
\end{aligned}
\]

By commutativity of \(\mathrm{BC}_k(R_q)\):
- \( r_A e_B = e_B r_A \)
- \( d_A s_B = s_B d_A \)

Thus \( K_A^e = K_B^s \).
\end{proof}

% ----------------
% Lemma 2
% ----------------
\begin{lemma}[Static--Ephemeral equality]\label{lem:se}
With the above notation,
\(
  K_A^{s} = K_B^{e}.
\)
\end{lemma}

\begin{proof}
We expand \( K_A^s \):
\[
\begin{aligned}
K_A^s &= (s_A y_B + e_A)s_A^{-1} \\
&= \left[s_A(r_B A + d_B)(r_B)^{-1} + e_A\right]s_A^{-1} \\
&= s_A r_B A (r_B)^{-1} s_A^{-1} + s_A d_B (r_B)^{-1} s_A^{-1} + e_A s_A^{-1}
\end{aligned}
\]

Using commutativity and conjugation:
\[
\begin{aligned}
K_A^s &= (s_A r_B) A (s_A r_B)^{-1} + (s_A d_B)(s_A r_B)^{-1} + (e_A r_B)(s_A r_B)^{-1}
\end{aligned}
\]

Now expand \( K_B^e \):
\[
\begin{aligned}
K_B^e &= (r_B t_A + d_B)(r_B)^{-1} \\
&= \left[r_B(s_A A + e_A)s_A^{-1} + d_B\right](r_B)^{-1} \\
&= r_B s_A A s_A^{-1} (r_B)^{-1} + r_B e_A s_A^{-1} (r_B)^{-1} + d_B (r_B)^{-1}
\end{aligned}
\]

Using commutativity:
\[
\begin{aligned}
K_B^e &= (s_A r_B) A (s_A r_B)^{-1} + (r_B e_A)(s_A r_B)^{-1} + (d_B s_A)(s_A r_B)^{-1}
\end{aligned}
\]

By commutativity of \(\mathrm{BC}_k(R_q)\):
- \( s_A d_B = d_B s_A \)
- \( e_A r_B = r_B e_A \)

Thus \( K_A^s = K_B^e \).
\end{proof}

% ----------------
% Theorem
% ----------------
\begin{theorem}[Authenticated correctness: \(K_A=K_B\)]
\label{thm:auth-correctness}
Assume \(\mathrm{BC}_k(R_q)\) is commutative and closed under inversion of the sampled
secrets, and that \(\alpha,\beta\) are the scalar  in \( R_q\).
Then the authenticated DLPL--DH key agreement defined above satisfies exact
correctness:
\[
  K_A \;=\; K_B \quad\text{in}\ \Rk.
\]
\end{theorem}

\begin{proof}
By Lemma~\ref{lem:ee} we have \(K_A^{e}=K_B^{s}\), and by
Lemma~\ref{lem:se} we have \(K_A^{s}=K_B^{e}\).
Since \(\alpha,\beta\) commute with all elements,
\[
  K_A
  = \alpha K_A^{e} + \beta K_A^{s}
  = \alpha K_B^{s} + \beta K_B^{e}
  = K_B.
\]
\end{proof}

\begin{remark}
The equalities above are purely algebraic and hold exactly in \(\Rk\).
No approximation or decoding step is required: the ``noise'' terms appear on
both sides under the same global conjugations, and thus do not break equality.
\end{remark}
% \subsubsection{Authenticated Protocol Definition}

% \begin{protocolbox}{Authenticated DLPL-DH Key Exchange}
% \textbf{Participants}: Alice ($A$) and Bob ($B$) with long-term keys $(pk_A, sk_A)$, $(pk_B, sk_B)$

% \textbf{Public parameters}: $\mathsf{params} = (n, q, k, \chi_s, \chi_e, A)$

% \textbf{Cryptographic functions}: 
% $H_1: \{0,1\}^* \to R_q$, $ H_2, H_3: \{0,1\}^* \to \{0,1\}^\lambda$, $\KDF: \{0,1\}^* \to \{0,1\}^\lambda$

% \medskip
% \textbf{Round 1: Ephemeral Key Exchange}
% \begin{enumerate}[leftmargin=1.3em]
%     \item \textbf{Alice}:
%     \begin{itemize}
%         \item Sample $r_A \gets \chi_s$ (invertible), $d_A \gets \chi_e$
%         \item Compute $y_A = (r_A A + d_A)(r_A)^{-1}$
%         \item Send $(pk_A, y_A)$ to Bob
%     \end{itemize}
    
%     \item \textbf{Bob}:
%     \begin{itemize}
%         \item Sample $r_B \gets \chi_s$ (invertible), $d_B \gets \chi_e$
%         \item Compute $y_B = (r_B A + d_B)(r_B)^{-1}$
%         \item Send $(pk_B, y_B)$ to Alice
%     \end{itemize}
% \end{enumerate}

% \textbf{Round 2: Authentication and Key Confirmation}
% \begin{enumerate}[leftmargin=1.3em, start=3]
%     \item \textbf{Alice}:
%     \begin{itemize}
%         \item Compute ephemeral component: $K_A^e = (r_A t_B + d_A)(r_A)^{-1}$
%         \item Compute static component: $K_A^s = (s_A t^e_B + e_A)s_A^{-1}$
%          \item Compute  tag: $\alpha = H_1(id_A, id_B, y_A, y_B)$
%           \item Compute  tag: $\beta = H_1(id_A, id_B, t_A, t_B) $
%         \item Combine: $K_A = \alpha K_A^e + \beta K_A^s$
%         \item Compute authentication tag: $\sigma_A = H_1(id_A, id_B, y_A, y_B, K_A)$
%         \item Send $\sigma_A$ to Bob
%     \end{itemize}
    
%     \item \textbf{Bob}:
%     \begin{itemize}
%         \item Compute ephemeral component: $K_B^e = (r_B t_A + d_B)(r_B)^{-1}$
%         \item Compute static component: $K_B^s = (s_B t^e_A + e_B)s_B^{-1}$
%         \item Compute  tag: $\alpha = H_1(id_A, id_B, y_A, y_B)$
%           \item Compute  tag: $\beta = H_1(id_A, id_B, t_A, t_B) $
%         \item Combine: $K_B = \beta K_B^e + \alpha K_B^s$
%         \item Verify $\sigma_A \stackrel{?}{=} H_1(id_A, id_B, y_A, y_B, K_B)$
%         \item If verification fails: abort
%         \item Compute response tag: $\sigma_B = H_2(id_B, id_A, y_B, y_A, K_B)$
%         \item Send $\sigma_B$ to Alice
%     \end{itemize}
    
%     \item \textbf{Alice}:
%     \begin{itemize}
%         \item Verify $\sigma_B \stackrel{?}{=} H_2(id_B, id_A, y_B, y_A, K_A)$
%         \item If verification fails: abort
%     \end{itemize}
% \end{enumerate}

% \textbf{Final Key Derivation}
% \begin{enumerate}[leftmargin=1.3em, start=6]
%     \item Both parties compute: $\mathsf{ss} = \KDF(K_A \parallel \sigma_A \parallel \sigma_B)$
%     \item Optional key confirmation: exchange $\H_3(\mathsf{ss})$
%     \item Output: shared secret $\mathsf{ss}$
% \end{enumerate}
% \end{protocolbox}

\subsubsection{Security Properties}

The authenticated DLPL-DH protocol provides the following security guarantees:

\begin{itemize}
    \item \textbf{Mutual Authentication}: The tags $\sigma_A, \sigma_B$ bind ephemeral keys to long-term identities, preventing man-in-the-middle attacks.
    
    \item \textbf{Forward Secrecy}: Compromise of long-term keys $(sk_A, sk_B)$ does not reveal past session keys due to the use of fresh ephemeral keys.
    
    \item \textbf{Key Confirmation}: The mutual verification of $\sigma_A, \sigma_B$ ensures both parties have computed the same shared secret.
    
    \item \textbf{Resistance to Replay Attacks}: The inclusion of fresh ephemeral values $y_A, y_B$ in the hash computations prevents replay.
    
    \item \textbf{Explicit Authentication}: The two-round structure with explicit authentication tags provides strong security against active adversaries.
\end{itemize}

\subsubsection{Security Reduction}

The security of the authenticated protocol can be reduced to the hardness of the DLPL-DH problem:

\begin{theorem}[Security of Authenticated DLPL-DH]
Under the \textsf{DLPL-DH} and \textsf{DLPL-D} assumptions, the authenticated DLPL-DH protocol provides secure authenticated key exchange in the random oracle model.
\end{theorem}

\begin{proofsketch}
The proof follows the game-hopping technique:
\begin{enumerate}
    \item Replace the shared secret $K$ with a random value using the \textsf{DLPL-DH} assumption
    \item Replace authentication tags with random values using the random oracle model
    \item Show that any adversary breaking authentication can solve the \textsf{DLPL-D} problem
\end{enumerate}
The combination of ephemeral and static keys ensures both forward secrecy and authentication.
\end{proofsketch}

% \subsubsection{Performance Considerations}

% The authenticated protocol requires:
% \begin{itemize}
%     \item \textbf{Computation}: 4 matrix multiplications and 2 inversions per party
%     \item \textbf{Communication}: 2 round trips with $(pk_i, t_i^e, \sigma_i)$ exchanges
%     \item \textbf{Storage}: Long-term keys of size $O(kn \log q)$ bits
% \end{itemize}

This represents a practical trade-off between security and efficiency for post-quantum authenticated key exchange.
\subsection{PKE Scheme Based on DLPL-DH}
We introduce a \emph{public-key encryption scheme} (PKE) based on the Diffie-Hellman type problem with noisy conjugation in the commutative block-circulant algebra \(\mathrm{BC}_k(R_q)\) (abbreviated \textsf{DLPL–DH}). The central idea follows the "Regev-like" intuition of LWE/RLWE constructions: we publish a noisy \emph{conjugation masking} \(t=(sA+e)s^{-1}\) of a master matrix \(A\in R_q^{k\times k}\).

\subsubsection{Public Parameters}
We work in the commutative algebra \(\mathrm{BC}_k(R_q), where \(R_q=\Rq\) (negacyclic, \(n\) power of two, \(q\) prime) and $\mathrm{H}: \Rk \to \{0,1\}^* $.
Public parameters:
\[
(n,q,k,\chi_s,\chi_d,\chi_r, A), \quad A\in R_q^{k\times k}, 
\]
with \(\chi_s,\chi_e,\chi_r\) centered discrete laws (binomials, etc.).  
We assume \(s\gets\chi_s\) is invertible with high probability (resample otherwise).

\subsubsection{PKE Definition}
\hspace{2}
\begin{protocolbox}{PKE–DLPL–DH}
\textbf{Keys.}
\begin{itemize}[leftmargin=1.3em]
  \item \(\KeyGen():\) Sample \(s\gets\chi_s\) (until invertible) and \(e\gets\chi_e\).
  Set
  \[
    t \coloneqq (sA+e)s\Inv \;=\; sAs\Inv + e\,s\Inv.
  \]
  Public key \(pk=(A,t)\). Secret key \(sk=s\).
\end{itemize}

\textbf{Encryption.}
\begin{itemize}[leftmargin=1.3em]
  \item \(\Enc(pk,m):\) For a message \(m\),
  % sample \(r\gets\chi_r\) (invertible, else resample), \(d\gets\chi_d\).
  % Compute
  \begin{enumerate}
        \item \((r,d) \gets \G(pk,m)\) (resample if \(r\) non-invertible).
      \item \text{if} (\(r\) non-invertible) \text{then} Goto 1
  \[
  \begin{aligned}
     u &\coloneqq (rA+d)r\Inv \;=\; rAr\Inv + d r\Inv ,\\
     v &\coloneqq \  m \oplus \mathrm{H}\!\big((rt+d)r\Inv\;\big)\\
       % &= rtr\Inv + d r\Inv + \EncMsg(m) 
  \end{aligned}
  \]
  \end{enumerate}
  
  \item Output ciphertext \(C=(u,v)\).
\end{itemize}

\textbf{Decryption.}
\begin{itemize}[leftmargin=1.3em]
  \item \(\Dec(sk,C):\) With \(sk=s\) and \(C=(u,v)\), compute
  \[
     \widehat{m} \;\coloneqq\;  \; v \oplus \mathrm{H}\!\big((s u+ e)s\Inv \;\big).
  \]
  Output \(\widehat{m}\).
\end{itemize}
\end{protocolbox}

\subsubsection{Correctness (Decoding)}
By expanding \(t=sAs\Inv+e\,s\Inv\) and \(u,v\):
\[
\begin{aligned}
v - (s u + e)s\Inv
&= \big(rtr\Inv + d r\Inv + \EncMsg(m)\big) - s\big(rAr\Inv + d r\Inv\big)s\Inv -e s\Inv\\
&= rsAs\Inv  r\Inv+e\,s\Inv + d r\Inv + \EncMsg(m) - s rAr\Inv s\Inv - d r\Inv - e s\Inv \\
&= \EncMsg(m) \;+\; \underbrace{\big( rsAs\Inv  r\Inv - s rAr\Inv s\Inv \big)}_{=\,0 \text{ by commutativity of }\mathrm{BC}_k(R_q)}.
\end{aligned}
\]

Thus $\DecMsg(v - (s u + e)s\Inv)= \DecMsg(\EncMsg(m))=m$.
% \subsubsection{Impossibility of Identifying $(r,d)$ from $(s,e)$, $m$, and $z$}
% \label{subsec:non-identifiability}

% We analyze, in the \emph{non-commutative} setting, whether a decryptor who knows
% the static secrets $(s,e)$, the message $m$, and the quantity
% \[
%   z \;:=\; v - u - \EncMsg(m)
% \]
% can recover the ephemeral randomness $(r,d)$ used at encryption time.

% \paragraph{Scheme recap (non-commutative regime).}
% We work in a unital algebra $\Acal$ (not necessarily commutative).
% Elements $A,t,s,e,r,d \in \Acal$ satisfy
% \[
%   t \;=\; (sA+e)s^{-1},\qquad
%   u \;=\; (rA + d)\,r^{-1},\qquad
%   v \;=\; (rt + d)\,r^{-1} + \EncMsg(m).
% \]
% We allow reusing the \emph{same} noise $d$ in $u$ and $v$ (as in the definition above),
% but the discussion easily adapts to independent noises $d_u,d_v$.

% \begin{lemma}[Form of $z$ without commutativity]\label{lem:z-form}
% In general (with no commutation assumption),
% \[
%   v-u \;=\; r\,(t - A)\,r^{-1} \;+\; \EncMsg(m),
% \]
% hence
% \[
%   \boxed{~~ z \;=\; v - u - \EncMsg(m) \;=\; r\,\Delta\, r^{-1} \quad
%   \text{where}\ \ \Delta \;:=\; t - A \;=\; sAs^{-1} - A + e\,s^{-1}. ~~}
% \]
% \end{lemma}

% \begin{proof}
% Compute directly
% \(
%   v-u = (rt+d)r^{-1} - (rA+d)r^{-1} + \EncMsg(m) = r(t-A)r^{-1} + \EncMsg(m)
% \).
% Subtracting $\EncMsg(m)$ yields $z=r\Delta r^{-1}$ with $\Delta:=t-A$.
% The expression of $\Delta$ follows from $t=(sA+e)s^{-1}$.
% \end{proof}

% Recovering $r$ from $(\Delta,z)$, i.e., $z=r\Delta r^{-1}$, is the
% \emph{Conjugacy Search Problem} (CSP) in the group of units $\Acal^\times$.

% \paragraph{Centralizer notation.}
% For $X\in\Acal$, let
% \[
%   C(X) \;:=\; \{\, g\in\Acal^\times \;:\; gX = Xg \,\}
% \]
% be the centralizer (inside the unit group).

% % ---------------------------------------------------------
% % Non-identifiability
% % ---------------------------------------------------------
% \begin{proposition}[Non-identifiability of $r$]\label{prop:non-identifiability-r}
% Assume there exists $r\in\Acal^\times$ such that $z=r\Delta r^{-1}$.
% Then, for every $g\in C(\Delta)$, one also has $z=(rg)\,\Delta\,(rg)^{-1}$.
% Consequently, $r$ is determined only \emph{on the right} up to a factor in $C(\Delta)$:
% the CSP solution is never unique as soon as $C(\Delta)$ is non-trivial.
% \end{proposition}

% \begin{proof}
% If $g\in C(\Delta)$, then $(rg)\,\Delta\,(rg)^{-1} = r(g\Delta g^{-1})r^{-1} = r\Delta r^{-1} = z$.
% Hence $rg$ is also a solution. If $C(\Delta)\neq\{I\}$, there are infinitely many solutions.
% \end{proof}

% \begin{remark}[Degenerate central case]
% If $\Delta \in \mathrm{Center}(\Acal)$, then $z=\Delta$ does \emph{not} depend on $r$:
% no information about $r$ is observable.
% \end{remark}

% \begin{lemma}[Expression of $d$ from $u$ and a fixed $r$]\label{lem:d-from-u-r}
% For any $r\in\Acal^\times$,
% \[
%   u=(rA+d)r^{-1} \quad\Longleftrightarrow\quad d \;=\; \big(u - rAr^{-1}\big)\,r.
% \]
% \end{lemma}

% \begin{proof}
% From $u=(rA+d)r^{-1}$, we get $ur = rA + d$. Thus $d = ur - rA = (u - rAr^{-1})r$.
% \end{proof}

% \begin{proposition}[Non-identifiability of $d$]\label{prop:non-identifiability-d}
% Let $r$ be any solution of the CSP $z=r\Delta r^{-1}$. Then the $d$ reconstructed via
% Lemma~\ref{lem:d-from-u-r} is generally not unique: if $g\in C(A)$ and
% $r' = rg$ is also an \emph{invertible} solution of the CSP (e.g., $g\in C(\Delta)\cap C(A)$),
% then
% \[
%   d' \;=\; \big(u - r'A(r')^{-1}\big)\,r' \;=\; d\,g.
% \]
% Therefore, $d$ is at best determined \emph{on the right} up to a factor in the centralizer $C(A)$.
% \end{proposition}

% \begin{proof}
% With $r'=rg$ and $g\in C(A)$, one has $r'A(r')^{-1} = r g A g^{-1} r^{-1} = r A r^{-1}$.
% By Lemma~\ref{lem:d-from-u-r},
% \(
%   d' = (u - r A r^{-1})\,rg = d\,g.
% \)
% \end{proof}

% \paragraph{Algorithmic perspective: the intertwiner space.}
% The equation $z=r\Delta r^{-1}$ rewrites as
% \[
%   r\Delta = z r \quad\Longleftrightarrow\quad r\Delta - z r = 0,
% \]
% i.e., a \emph{linear} system in the coefficients of $r$ (matrix view of $\Acal$).
% The set
% \[
%   \Hom_{\Delta}^z \;:=\; \{\, X\in\Acal \;:\; X\Delta = zX \,\}
% \]
% is a vector space (often of non-negligible dimension). It typically contains
% \emph{non-invertible} solutions. The mere linear solve does not guarantee the existence
% of invertible solutions (cryptographically acceptable $r$). Even when one is found,
% Proposition~\ref{prop:non-identifiability-r} shows it is determined at best modulo $C(\Delta)$.

% \begin{theorem}[General impossibility of recovering $(r,d)$]\label{thm:impossibility}
% In the non-commutative framework above, a decryptor who knows $(s,e)$, $m$, and
% $z=v-u-\EncMsg(m)$ cannot, in general, uniquely identify $r$ (at best modulo $C(\Delta)$),
% nor uniquely identify $d$ (at best modulo $C(A)$). In particular, the exact pair $(r,d)$
% is not determined by $(s,e,m,z)$ alone, except under very restrictive structural assumptions
% (trivial centralizers and a CSP that is solvable with uniqueness).
% \end{theorem}

% \begin{proof}
% By Lemma~\ref{lem:z-form}, $z=r\Delta r^{-1}$. Non-uniqueness of $r$ follows from
% Proposition~\ref{prop:non-identifiability-r}. For any representative $r$,
% Lemma~\ref{lem:d-from-u-r} gives $d=(u - rAr^{-1})r$. Replacing $r$ by $rg$ with
% $g\in C(\Delta)\cap C(A)$ (a frequent case), we get $d' = d g$ by
% Proposition~\ref{prop:non-identifiability-d}. Hence $(r,d)$ is not identifiable.
% \end{proof}

% \begin{remark}[Special cases where identifiability might hold]
% If $C(\Delta)=\{I\}$ and $C(A)=\{I\}$ (trivial centralizers) \emph{and} if one has an algorithm
% that actually produces an invertible solution $r$ of the CSP (which is itself non-trivial),
% then $r$ and $d$ would become unique. These assumptions are, however, very strong and do not
% match the general setting considered here.
% \end{remark}

% \paragraph{Cryptographic consequence.}
% The quantity $z$ is a \emph{conjugation image} of $\Delta=t-A$:
% it does \emph{not} reveal $(r,d)$ individually. Thus, even a decryptor who knows $(s,e)$ and $m$
% cannot reconstruct the encryption-time ephemeral randomness. This supports using, for semantic
% security, a KEM--DEM transformation or an encapsulation that avoids re-inserting the message
% additively inside $\Acal$.



% \subsection{IND-CPA Security Proof}
% \begin{definition}[IND-CPA Security]
% A PKE scheme is IND-CPA secure if for any PPT adversary $\mathrm{BC}_k(R_q)$:
% \[
% \Adv^{\text{IND-CPA}}_{\mathrm{BC}_k(R_q)}(1^\lambda) = \left| \Pr[\text{IND-CPA}_{\mathrm{BC}_k(R_q)}(1^\lambda) = 1] - \frac{1}{2} \right| = \negl(\lambda)
% \]
% \end{definition}
% \begin{theorem}[IND-CPA Security]
% Under the DLPL-D assumption, the PKE scheme is IND-CPA secure.
% \end{theorem}

% \begin{proof}
% We proceed via a sequence of games.

% \noindent\textbf{Game $G_0$:} The real IND-CPA game.
% \begin{enumerate}
%     \item Challenger generates $(pk, sk) \leftarrow \KeyGen()$ with $pk = (A, t)$, $sk = s$
%     \item Adversary $\mathrm{BC}_k(R_q)$ receives $pk$ and outputs $(m_0, m_1)$
%     \item Challenger picks $b \leftarrow \{0,1\}$, computes $C^* = (u^*, v^*) \leftarrow \Enc(pk, m_b)$
%     \item $\mathrm{BC}_k(R_q)$ receives $C^*$ and outputs $b'$
%     \item $\mathrm{BC}_k(R_q)$ wins if $b' = b$
% \end{enumerate}

% \noindent\textbf{Game $G_1$:} Replace $t$ with uniform $U \leftarrow \mathrm{BC}_k(R_q)_k(R_q)$.

% We construct a reduction $\mathcal{B}$ to DLPL-D:
% \begin{itemize}
%     \item $\mathcal{B}$ receives challenge $(A, T)$ where $T$ is either $t$ or $U$
%     \item $\mathcal{B}$ sets $pk = (A, T)$ and simulates $G_0/G_1$ for $\mathrm{BC}_k(R_q)$
%     \item If $\mathrm{BC}_k(R_q)$ wins, $\mathcal{B}$ outputs 1 (real), else 0 (random)
% \end{itemize}

% By the DLPL-D assumption:
% \[
% \left| \Pr[G_0] - \Pr[G_1] \right| \leq \Adv^{\text{DLPL-D}}_{\mathcal{B}}(1^\lambda)
% \]

% \noindent\textbf{Game $G_2$:} Replace $u^*$ with uniform $U_1 \leftarrow \mathrm{BC}_k(R_q)_k(R_q)$.

% In $G_1$, $t$ is uniform. We have:
% \[
% u^* = (rA + d)r^{-1} = rAr^{-1} + dr^{-1}
% \]
% Since $A$ is uniform and $r$ is invertible, $rAr^{-1}$ is uniform in $\mathrm{BC}_k(R_q)_k(R_q)$. The term $dr^{-1}$ is small and statistically negligible. Thus:
% \[
% \left| \Pr[G_1] - \Pr[G_2] \right| \leq \negl(\lambda)
% \]

% \noindent\textbf{Game $G_3$:} Replace $v^*$ with $U_2 + \EncMsg(m_b)$ where $U_2 \leftarrow \mathrm{BC}_k(R_q)_k(R_q)$.

% In $G_2$, we have:
% \[
% v^* = (rt + d)r^{-1} + \EncMsg(m_b)
% \]
% With $t$ uniform and $r$ invertible, $(rt + d)r^{-1}$ is uniform. Thus:
% \[
% \left| \Pr[G_2] - \Pr[G_3] \right| \leq \negl(\lambda)
% \]

% \noindent\textbf{Game $G_4$:} Replace $v^*$ with purely uniform $U_2$.

% In $G_3$, $v^*$ is already uniform plus a constant term, so removing $\EncMsg(m_b)$ doesn't change the distribution:
% \[
% \Pr[G_3] = \Pr[G_4]
% \]

% In $G_4$, the ciphertext $(u^*, v^*)$ is completely independent of $m_b$, so:
% \[
% \Pr[G_4] = \frac{1}{2}
% \]

% Combining all inequalities:
% \begin{align*}
% \Adv^{\text{IND-CPA}}_{\mathrm{BC}_k(R_q)}(1^\lambda) &= \left| \Pr[G_0] - \frac{1}{2} \right| \\
% &\leq \left| \Pr[G_0] - \Pr[G_1] \right| + \left| \Pr[G_1] - \Pr[G_2] \right| \\
% &\quad + \left| \Pr[G_2] - \Pr[G_3] \right| + \left| \Pr[G_3] - \frac{1}{2} \right| \\
% &\leq \Adv^{\text{DLPL-D}}_{\mathcal{B}}(1^\lambda) + \negl(\lambda)
% \end{align*}

% Therefore, under the DLPL-D assumption, the PKE scheme is IND-CPA secure.
% \end{proof}



\subsection{Key Encapsulation Mechanisms}
We present an IND-CCA2 \emph{Key Encapsulation Mechanism} (KEM) derived from the PKE over the block-circulant algebra \(\mathrm{BC}_k(R_q)\) by applying the Fujisaki–Okamoto (FO) transformation in the random oracle model~\cite{FujisakiOkamoto-CRYPTO99,FujisakiOkamoto-PKC99,FujisakiOkamoto-JoC2013}. On the encapsulation side, the sender chooses a random seed \(\sigma\) and deterministically derives the "randomness" \((r,d)=\mathsf{G}(pk,\sigma)\); this produces a header \(C=(u,v)\) analogous to the PKE ciphertext, while the shared key is \(\mathsf{ss}=\mathsf{KDF}\!\big(\sigma \parallel \mathsf{H'}(pk \parallel C)\big)\). Upon decapsulation, the receiver recovers \(\widehat{\sigma}\) through the decoding relation (exploiting the commutativity of \(\mathrm{BC}_k(R_q)\) to cancel the main term and leave only decodable noise), regenerates \((\widehat r,\widehat d)=\mathsf{G}(pk,\widehat\sigma)\), then verifies \(C\) by deterministic re-encryption; if verification fails, a fallback to a secret seed \(z\) ensures the indistinguishability of \(\mathsf{ss}\). This discipline removes decapsulation oracle channels and elevates the IND-CPA security of the PKE (under the DLPL–DH assumption) to IND-CCA2 security for the KEM~\cite{FujisakiOkamoto-CRYPTO99,FujisakiOkamoto-PKC99}.

\begin{protocolbox}{KEM--DLPL--DH (FO--CCA2)}
\textbf{Keys.}
\begin{itemize}[leftmargin=1.3em]
  \item \(\KeyGen():\) Sample \(s\gets\chi_s\) (resample until invertible), \(e\gets\chi_e\).
        Set
        \[
          t \coloneqq (sA+e)s^{-1} = sAs^{-1}+e\,s^{-1}\in\Rk.
        \]
        Public key \(pk=(A,t)\). Secret key \(sk=(s,e,z)\), where \(z\gets\{0,1\}^{\ell_z}\) is a
        \emph{fallback seed} (FO) for decapsulation failure.
\end{itemize}

\textbf{Encapsulation.}
\begin{itemize}[leftmargin=1.3em]
  \item \(\Encap(pk):\)
    \begin{enumerate}[leftmargin=1.3em]
      \item Choose \(\sigma \gets \{0,1\}^{\ell_\sigma}\).
      \item \((r,d) \gets \G(pk,\sigma)\) (resample if \(r\) non-invertible).
      \item \text{if} (\(r\) non-invertible) \text{then} Goto 1
      \item Compute
      \[
        \begin{aligned}
          u &\coloneqq (rA+d)\,r^{-1} \;=\; rAr^{-1} + d\,r^{-1} \in \Rk,\\
          v &\coloneqq  \sigma \oplus \mathrm{H}\!\big((rt+d)\,r^{-1} \;\big)
             .
        \end{aligned}
      \]
      \item Set \(C \coloneqq (u,v)\) and \(\tau \coloneqq \Htag(pk \parallel C)\).
      \item Shared key \(\mathsf{ss} \coloneqq \KDF(\sigma \parallel \tau)\).
      \item Output \((C,\mathsf{ss})\).
    \end{enumerate}
\end{itemize}

\textbf{Decapsulation.}
\begin{itemize}[leftmargin=1.3em]
  \item \(\Decap(sk,pk,C=(u,v)):\)
    \begin{enumerate}[leftmargin=1.3em]
      \item \(\widehat{\sigma} \coloneqq v \oplus \mathrm{H}\!\big( (s\,u + e)\,s^{-1}\big)\).
      \item \((\widehat{r},\widehat{d}) \gets \G(pk,\widehat{\sigma})\).
      \item \text{if} ( \(\widehat{r}\) non-invertible) \text{then} $\sigma^\star \leftarrow z$
      \item \text{else}
      \begin{enumerate}[leftmargin=1.3em]
      \item Re-encrypt deterministically from \(\widehat{\sigma}\):
      \[
        \begin{aligned}
          \widehat{u} &\coloneqq (\widehat{r}A+\widehat{d})\,\widehat{r}^{-1},\\
          \widehat{v} &\coloneqq \widehat{\sigma} \oplus \mathrm{H}\!\big( (\widehat{r}t+\widehat{d})\,\widehat{r}^{-1}\big)
        \end{aligned}
      \]
      \item \textbf{FO test}:
      \[
        \text{if } (\widehat{u},\widehat{v}) = (u,v) \text{ then } \sigma^\star \leftarrow \widehat{\sigma}
        \;\; \text{else}\;\; \sigma^\star \leftarrow z.
      \]
       \end{enumerate}
      \item \(\tau \coloneqq \Htag(pk \parallel C)\), \quad \(\mathsf{ss} \coloneqq \KDF(\sigma^\star \parallel \tau)\).
      \item Output \(\mathsf{ss}\).
    \end{enumerate}
\end{itemize}
\end{protocolbox}

\paragraph{Correctness.}
If \(C\) is honest, then \(\widehat{\sigma}=\sigma\) with probability \(1-\varepsilon_{\text{dec}}\) (negligible),
and re-encapsulation yields \((\widehat{u},\widehat{v})=(u,v)\), hence \(\sigma^\star=\sigma\) and
\(\mathsf{ss}=\KDF(\sigma\parallel \Htag(pk\parallel C))=\mathsf{ss}_{\text{encap}}\).

% \subsubsection{IND-CCA2 Security via Fujisaki-Okamoto Transformation}

% \begin{theorem}[IND-CCA2 Security]
% In the random oracle model, if the PKE scheme is IND-CPA secure and $\gamma$-spread, then the KEM is IND-CCA2 secure.
% \end{theorem}

% \begin{proof}[Proof Sketch]
% We outline the main steps:

% \begin{enumerate}
%     \item \textbf{Random Oracle Programming}: The simulator programs $G$, $H'$, and KDF to maintain consistency while answering decapsulation queries.
    
%     \item \textbf{Game Sequence}:
%     \begin{itemize}
%         \item Replace the encapsulated key with random
%         \item Use the random oracle to extract the challenge message
%         \item Handle decryption failures using the fallback seed $z$
%     \end{itemize}
    
%     \item \textbf{Reduction to IND-CPA}: Any adversary breaking IND-CCA2 can be used to break IND-CPA by:
%     \begin{itemize}
%         \item Simulating decapsulation queries using random oracle programming
%         \item Extracting the challenge message from random oracle queries
%         \item Using the adversary's advantage to distinguish the PKE challenge
%     \end{itemize}
    
%     \item \textbf{Security Bound}: The advantage is bounded by:
%     \[
%     \Adv^{\text{IND-CCA2}}_{\mathrm{BC}_k(R_q)}(1^\lambda) \leq \Adv^{\text{IND-CPA}}_{\mathcal{B}}(1^\lambda) + \frac{q_{\text{dec}}}{2^{\ell_\sigma}} + \negl(\lambda)
%     \]
%     where $q_{\text{dec}}$ is the number of decapsulation queries.
% \end{enumerate}

% The proof follows the standard Fujisaki-Okamoto framework, adapted to our algebraic structure. The commutativity of $\mathrm{BC}_k(R_q)_k(R_q)$ ensures correctness, while the DLPL-D hardness provides the foundational security.
% \end{proof}
% \paragraph{Security notes (sketch).}
% (i) \(\G,\Htag,\KDF\) are modeled as random oracles (classical FO).
% (ii) The test \((\widehat{u},\widehat{v})=(u,v)\) is \emph{constant-time} and acts as implicit integrity verification.
% (iii) The fallback \(\sigma^\star\leftarrow z\) prevents oracle exploitation of decapsulation.
% (iv) The pseudorandomness of \(C\) and indistinguishability of \(\mathsf{ss}\) reduce to the hardness
% of DLPL–DH in \(\mathrm{BC}_k(R_q)\), plus RO security.

% \subsection{DLPL--PSS--HB--\textsc{minSig}: A PSS–Style Signature}
% \label{sec:minsig}

% \paragraph{Algebraic setting.}
% Let $R_q=\Z_q[x]/(x^n{+}1)$ with $n$ a power of two and $q$ a suitable prime.
% We work in the commutative block–circulant algebra $\BC_k(R_q)\subseteq M_k(R_q)$, closed under $+,\cdot$ and inversion whenever it exists.
% All matrix equalities are taken modulo~$q$ and operations are componentwise in $M_k(R_q)$.

% \paragraph{DLPL public key relation.}
% The public key follows the DLPL masking relation
% \[
%   t \;=\; (sA+e)\,s^{-1} \in M_k(R_q),
% \]
% where $A\leftarrow M_k(R_q)$ is uniform, $s\gets\chi_s$ is sampled until invertible in $\BC_k(R_q)$, and $e\gets\chi_e$ is an error from a narrow distribution.
% The secret key is $\sk=(s,e)$; the public key is $\pk=(A,t)$.

% \subsubsection{High/Low–Bits Decomposition and Coset Test}
% \label{subsec:hlb}

% We use the centered representative $\langle x\rangle_q\in(-\tfrac q2,\tfrac q2]$ for $x\in\Z_q$, and for a step $\gamma\in\N$ define, coefficientwise on $M_k(R_q)$,
% \[
%   \High_\gamma(x)\;=\;\Big\lfloor \frac{\langle x\rangle_q}{\gamma}\Big\rceil,
%   \qquad
%   \Low_\gamma(x)\;=\;\langle x\rangle_q \;-\; \gamma\,\High_\gamma(x).
% \]
% Crucial property (\emph{small-perturbation invariance}): if $\|w\|_\infty<\gamma/2$, then $\High_\gamma(x{+}w)=\High_\gamma(x)$ and $\|\Low_\gamma(x{+}w)\|_\infty=\|\Low_\gamma(x)+w\|_\infty<\gamma/2$.

% We will pick bounds $B_z,B_w$ and a step $\gamma$ satisfying $2B_w<\gamma\le\lfloor q/2\rfloor$; this ensures that for any honest signature the residual term $w$ (defined below) lies inside the \emph{coset window} enforced by the verifier.

% \subsubsection{Signature Space, Hashes, and Challenges}
% \label{subsec:hashes}

% We work in the Random Oracle Model (ROM) with domain-separated hash functions:
% \begin{itemize}[leftmargin=1.35em]
% \item $H_c:\{0,1\}^\ast\to\{0,1\}^{\lambda}$, parsed as a seed to derive a \emph{challenge} $c$ in a prescribed small set $\mathcal{C}$ (e.g., ternary of fixed Hamming weight $\omega$ spread over the $k\times k$ block-structure).
% \item Optionally, $H_\mathrm{prf}$ to expand seeds deterministically into small vectors/matrices in $\BC_k(R_q)$.
% \end{itemize}
% We denote by $\mathcal{C}$ a public distribution of small challenges (e.g., $\{-1,0,1\}$-valued with fixed weight $\omega$); $c\leftarrow \mathrm{Parse}_\mathcal{C}(H_c(\cdot))$.

% \subsubsection{The DLPL--PSS--HB--\textsc{minSig} Scheme}
% \label{sec:dlpl-pss-hb-minsig}
% \paragraph{Algebraic Setting and Public Parameters}
% \label{subsec:minsig-params}
% \begin{description}[leftmargin=1.25em,style=sameline]
%   \item[Base Ring.] $R_q=\Rq$ with $n$ a power of two and $q$ prime.
%   \item[Algebra.] We operate in the commutative block–circulant algebra $\BCk(R_q)\subseteq \Mk(R_q)$, closed under $+,\cdot$, and (when defined) inversion.
%   \item[DLPL Relation.] The public key satisfies $t=(sA+e)s^{-1}\in \Mk(R_q)$ with $A\gets \Mk(R_q)$ uniform, $s\gets\chi_s$ (resampled until invertible in $\BCk(R_q)$), and $e\gets\chi_e$.
%   \item[Distributions.] Ephemeral $r$ and secret $s$ from $\chi_s$; errors $d,e$ from $\chi_e$ (e.g., centered binomial).
%   \item[High/Low Bits.] For $\gamma\in\mathbb{N}$ and centered representative $\langle x\rangle_q\in(-\tfrac q2,\tfrac q2]$,
%   \[
%     \operatorname{High}_\gamma(x)=\Big\lfloor \tfrac{\langle x\rangle_q}{\gamma}\Big\rceil,\qquad
%     \operatorname{Low}_\gamma(x)=\langle x\rangle_q-\gamma\,\operatorname{High}_\gamma(x),
%   \]
%   coefficientwise in $\Mk(R_q)$. If $\|w\|_\infty<\gamma/2$, then $\operatorname{High}_\gamma(x{+}w)=\operatorname{High}_\gamma(x)$.
%   \item[Bounds.] Choose $B_z,B_w,\gamma$ with $2B_w<\gamma\le\lfloor q/2\rfloor$.
%   \item[Challenge.] $c\in\mathcal{C}$ is a small challenge (e.g., sparse ternary of fixed weight $\omega$), derived as $c\gets \mathrm{Parse}_\mathcal{C}(H_c(\cdot))$ with domain-separated ROM hash $H_c$.
% \end{description}

% \begin{protocolbox}{DLPL--PSS--HB--\textsc{minSig}: Key Generation}
% \label{prot:minsig-keygen}
% \textbf{Input:} security parameters $(n,q,k)$; distributions $\chi_s,\chi_e$.\\
% \textbf{Output:} public key $\pk=(A,t)$; secret key $\sk=(s,e)$.
% \begin{enumerate}[leftmargin=1.25em, itemsep=0.2em]
%   \item Sample $s\gets\chi_s$ until invertible in $\BCk(R_q)$; sample $e\gets\chi_e$.
%   \item Draw $A\leftarrow \Mk(R_q)$ uniformly at random.
%   \item Compute $t \leftarrow (sA+e)s^{-1}\in \Mk(R_q)$.
%   \item Output $\pk=(A,t)$ and $\sk=(s,e)$.
% \end{enumerate}
% \end{protocolbox}

% \begin{protocolbox}{DLPL--PSS--HB--\textsc{minSig}: Signing}
% \label{prot:minsig-sign}
% \textbf{Public params:} bounds $B_z,B_w$, step $\gamma$, challenge space $\mathcal{C}$.\\
% \textbf{Input:} $\sk=(s,e)$, $\pk=(A,t)$, message $m$. \quad \textbf{Output:} $\sigma=(\rho,c,z)$.
% \begin{enumerate}[leftmargin=1.25em, itemsep=0.2em]
%   \item Repeat:
%     \begin{enumerate}[leftmargin=1.25em, itemsep=0.2em]
%       \item Sample $r\gets\chi_s$, $d\gets\chi_e$, and salt $\rho\gets\{0,1\}^{\lambda_\rho}$.
%       \item Compute hidden commit $y \leftarrow t r - r A - d$ and $h_b \leftarrow \operatorname{High}_\gamma(y)$.
%       \item Set $c \leftarrow \mathrm{Parse}_\mathcal{C}\!\big(H_c(\pk\,\|\,h_b\,\|\,\rho\,\|\,m)\big)$.
%       \item Set $z \leftarrow r + c s$.
%     \end{enumerate}
%   \item Until $\|z\|_\infty \le B_z$.
%   \item Output $\sigma=(\rho,c,z)$.
% \end{enumerate}
% \end{protocolbox}

% \begin{protocolbox}{DLPL--PSS--HB--\textsc{minSig}: Verification}
% \label{prot:minsig-verify}
% \textbf{Public params:} $B_z,B_w,\gamma$, $\mathcal{C}$.\\
% \textbf{Input:} $\pk=(A,t)$, message $m$, signature $\sigma=(\rho,c,z)$. \quad \textbf{Output:} accept / reject.
% \begin{enumerate}[leftmargin=1.25em, itemsep=0.2em]
%   \item If $\|z\|_\infty > B_z$, \textbf{reject}.
%   \item Compute $x \leftarrow t z - z A$; set $h_b' \leftarrow \operatorname{High}_\gamma(x)$ and $\ell' \leftarrow \operatorname{Low}_\gamma(x)$.
%   \item If $\|\ell'\|_\infty > B_w$, \textbf{reject} \hfill (coset / small-residue test).
%   \item Compute $c' \leftarrow \mathrm{Parse}_\mathcal{C}\!\big(H_c(\pk\,\|\,h_b'\,\|\,\rho\,\|\,m)\big)$.
%   \item Accept iff $c'=c$.
% \end{enumerate}
% \end{protocolbox}

% \paragraph{Correctness.}
% With $z=r+cs$,
% \[
%   tz- zA \;=\; t(r{+}cs)-(r{+}cs)A \;=\; (tr{-}rA) + c(ts{-}sA) \;=\; y + (d{+}ce) \;=\; y+w.
% \]
% Since $\|w\|_\infty\le B_w<\gamma/2$, we have $\operatorname{High}_\gamma(tz{-}zA)=\operatorname{High}_\gamma(y)$ and $\|\operatorname{Low}_\gamma(tz{-}zA)\|_\infty\le B_w$, so the verifier reconstructs $h_b'$ and the ROM challenge $c'$ exactly.

% \subsubsection{Security Outline (EUF–CMA in the ROM)}
% \label{subsec:security}

% We sketch a standard ROM reduction to a bounded Module–SIS problem over $\BC_k(R_q)$; a full proof follows the \emph{small-residue} paradigm used in lattice-based signatures with high/low-bit tests.

% \begin{theorem}[Informal]
% \label{thm:eufcma}
% Assume that for random $(A,t)$ as above and typical parameters $(B_z,B_w,\gamma)$ with $2B_w<\gamma$, it is hard to find a nonzero $z\in \BC_k(R_q)$ with $\|z\|_\infty\le B_z$ and $u\in M_k(R_q)$ with $\|u\|_\infty\le B_w$ such that
% \[
%  (t-A)\,z \;=\; \gamma\,h_b \;+\; u
%  \quad\text{for some}\quad h_b\in\Z^{(\cdot)}.
% \]
% Then DLPL--PSS--HB--\textsc{minSig} is EUF--CMA secure in the ROM.
% \end{theorem}

% \begin{proof}[Proof sketch]
% We program the random oracle $H_c$ adaptively.
% Given a forger producing $(\rho,c,z)$ on $m$ that verifies, we have
% \[
%  x = t z - zA \;=\; \gamma\,h_b' + \ell',
%  \quad\text{with}\quad
%   h_b'=\High_\gamma(x),\ \ \|\ell'\|_\infty\le B_w.
% \]
% Moreover $\|z\|_\infty\le B_z$ and $c = \mathrm{Parse}_\mathcal{C}(H_c(\pk\|h_b'\|\rho\|m))$.
% The forgery thus yields a short preimage $z$ for the public linear map $L_{t,A}: z \mapsto (t-A)z$ landing inside a $\gamma$-coset with a bounded offset $\ell'$.
% A standard reduction embeds a random bounded Module--SIS instance into $L_{t,A}$ (via the vectorization map and Kronecker linearization over $R_q$) and answers signing queries by simulating high bits through ROM programming while preserving the small-residue window.\footnote{One may implement $c$ as a sparse ternary and interpret $H_c$ outputs as seeds into a public sampler, ensuring domain separation and programmability.}
% Any successful forgery solves the underlying bounded Module--SIS instance with non-negligible probability.
% \end{proof}

% \paragraph{On forking/extraction.}
% Unlike Fiat–Shamir-with-rejection schemes that publish an explicit commitment $y$, our minimal signature removes $y$ entirely.
% Therefore, the classical two-challenge extraction of $(s,e)$ via forking is \emph{not} used.
% Security relies instead on the small-residue coset constraint turning any forgery into a bounded Module--SIS solution (Theorem~\ref{thm:eufcma}).
% If explicit knowledge extraction is desired, retain $y$ (or a one-bit hint per coefficient) and use the standard forking lemma.

% \subsubsection{Instantiation Guidelines}
% \label{subsec:parameters}

% \noindent\textbf{Challenge space.}
% Let $c\in\mathcal{C}$ be parsed as a sparse ternary element in $\BC_k(R_q)$ (e.g., fixed weight $\omega$ spread across blocks), derived deterministically from $H_c$ for unique decoding.

% \smallskip
% \noindent\textbf{Bounds and step.}
% Pick $B_w \approx B_d + \omega B_e$ (heuristic upper bound for $w=d+ce$ under convolution in $\BC_k(R_q)$) and $B_z$ to keep acceptance $\gtrsim 0.4$.
% Choose $\gamma=\lfloor q/2^t\rfloor$ with $t\in[7,10]$ so that $2B_w<\gamma$.

% \smallskip
% \noindent\textbf{Compression.}
% Exploit the block–circulant isomorphism $\varphi:\BC_k(R_q)\to R_q^k$ and store only the first block row of any $\BC_k(R_q)$ element.  This reduces public key and signature sizes by a factor $\approx k$ at equal parameters.

% \smallskip
% \noindent\textbf{Domain separation.}
% Prefix distinct labels for $H_c$ and any PRF expansions; include $\pk$ in all hash inputs to prevent cross-key malleability.

% \subsubsection{Sizes and Cost (Symbolic)}
% Let $N := k\cdot n$ be the \emph{effective} polynomial dimension.
% Ignoring block-circulant compression, the signature consists of
% \[
%   |\sigma| \;=\; |\rho| \;+\; |c| \;+\; |z|.
% \]
% With $\varphi$-compression, costs are in $R_q^k$ coordinates instead of $M_k(R_q)$.
% Verification requires two public matrix–vector products ($tz$ and $zA$) and two simple per-coefficient tests (high/low-bits window and challenge recomputation).
% % \begin{table}[t]
% % \centering
% % \caption{Suggested parameters and acceptance estimates for DLPL--PSS--HB--\textsc{minSig}}
% % \label{tab:params-minsig}
% % \renewcommand{\arraystretch}{1.15}
% % \begin{tabular}{lcccccccccc}
% % \toprule
% % Level & $(n,k)$ & $N{=}kn$ & $q$ & $t$ & $\gamma$ & $\omega$ & $(\eta_s,\eta_e)$ & $B_z$ & $B_w$ & $|\sigma|$ [B] \\
% % \midrule
% % L1 & $(256,2)$ & $512$ & $8380417$ & $10$ & $8184$ & $60$ & $(3,2)$ & $54$ & $122$ & $\;\approx 539$ \\
% % L3 & $(256,3)$ & $768$ & $8380417$ & $10$ & $8184$ & $85$ & $(3,2)$ & $68$ & $172$ & $\;\approx 901$ \\
% % L5 & $(512,4)$ & $2048$ & $8380417$ & $10$ & $8184$ & $110$ & $(3,2)$ & $80$ & $222$ & $\;\approx 2229$ \\
% % \bottomrule
% % \end{tabular}
% % \\[2pt]
% % \footnotesize
% % $B_w \approx B_d + \omega B_e$ with $B_d=B_e=2$ (CB$_2$ support). \;
% % $|\sigma| = |\rho| + |c| + |z|$ where $|z| = \lceil N\cdot \lceil\log_2(2B_z{+}1)\rceil/8\rceil$ bytes and
% % $|c| \approx \lceil \omega(\lceil\log_2 N\rceil + 1)/8\rceil$ bytes.
% % \end{table}

% \subsubsection{Discussion}
% The DLPL--PSS--HB--\textsc{minSig} design mirrors the \emph{salted, hash-then-sign} spirit of PSS while being native to the DLPL linear relation.
% By pushing the commitment into the ROM via $\High_\gamma(\cdot)$ and enforcing a \emph{coset window} with $\Low_\gamma(\cdot)$, we remove $y$ and $w$ from the signature without sacrificing soundness.
% The resulting scheme is compact, simple to verify, and admits standard parameter tuning to target NIST L1/L3/L5.

\section{The DLPL-Sign Signature Scheme}

% \subsection{System Parameters}

The scheme uses the following parameters:
\begin{itemize}
    \item $n$: polynomial degree (power of 2)
    \item $q$: prime modulus
    \item $k$: dimension of block-circulant matrices
    \item $\chi_s, \chi_e$: distributions for secrets and errors
    \item $\sigma$: standard deviation for Gaussian sampling
    \item $\rho$: rejection bound for signature norm
    \item $\lambda_r$: bit length of signature salt
\end{itemize}

% \subsection{Key Generation}

\begin{protocolbox}{DLPL-Sign.KeyGen}
    \textbf{Input}: None \\
    \textbf{Output}: Key pair $(\mathsf{pk}, \mathsf{sk})$
    \begin{enumerate}[label=\arabic*., leftmargin=*, itemsep=2pt]
        \item Sample $s \leftarrow \chi_s$ until invertible in $\mathrm{BC}_k(R_q)$.
        \item Sample $e \leftarrow \chi_e$.
        \item Compute $t = (s A + e) s^{-1}$.
        \item Return $\mathsf{pk} = (A, t)$ and $\mathsf{sk} = (s, e)$.
    \end{enumerate}
\end{protocolbox}

\begin{protocolbox}{DLPL-Sign.Sign}
    \textbf{Input}: Secret key $\mathsf{sk} = (s, e)$, message $\mathsf{msg}$ \\
    \textbf{Output}: Signature $(r, S)$ or $\bot$
    \begin{enumerate}[label=\arabic*., leftmargin=*, itemsep=2pt]
        \item Choose salt $r \leftarrow \{0,1\}^{\lambda_r}$.
        \item Compute $\mu = H(r \| \mathsf{msg}) \in R_q^k$.
        \item Construct $B = [I_k \otimes t - A^\top \otimes I_k \mid -I_{k^2}]$.
        \item Find $\mathbf{z}_0$ such that $B \cdot \mathbf{z}_0 = \mu$.
        \item Sample $\mathbf{z} \leftarrow D_{\mathcal{L} + \mathbf{z}_0, \sigma}$ (Gaussian sampling using trapdoor).
        \item If $\|\mathbf{z}\| > \rho$, then \textbf{restart}.
        \item $S = \text{Compress}(\mathbf{z})$ (using Falcon-style compression).
        \item Return $(r, S)$.
    \end{enumerate}
\end{protocolbox}

\begin{protocolbox}{DLPL-Sign.Verify}
    \textbf{Input}: Public key $\mathsf{pk} = (A, t)$, message $\mathsf{msg}$, signature $(r, S)$ \\
    \textbf{Output}: Accept or reject
    \begin{enumerate}[label=\arabic*., leftmargin=*, itemsep=2pt]
        \item $\mathbf{z} = \text{Decompress}(S)$.
        \item If $\|\mathbf{z}\| > \rho$, then return \textbf{reject}.
        \item Compute $\mu = H(r \| \mathsf{msg})$.
        \item Construct $B = [I_k \otimes t - A^\top \otimes I_k \mid -I_{k^2}]$.
        \item If $B \cdot \mathbf{z} \neq \mu$, then return \textbf{reject}.
        \item Return \textbf{accept}.
    \end{enumerate}
\end{protocolbox}



\subsection*{Correctness Proof}

\begin{theorem}[Correctness of DLPL-Sign]
Let $(\mathsf{pk}, \mathsf{sk}) \leftarrow \text{KeyGen}()$ and $(r, S) \leftarrow \text{Sign}(\mathsf{sk}, \mathsf{msg})$. Then:
\[
\Pr[\text{Verify}(\mathsf{pk}, \mathsf{msg}, (r, S)) = \text{accept}] = 1 - \epsilon(\lambda)
\]
where $\epsilon(\lambda)$ is a negligible function.
\end{theorem}

\begin{proof}
The proof proceeds in several steps:
% --- Point 1: Constructing z_0 taking (s,e) into account
\paragraph{Step 1:  Construction of \texorpdfstring{$z_0$} taking $(s,e)$ into account.}

Let $A,t\in \mathrm{BC}_k(R_q)$, and $(s,e)\in \mathrm{BC}_k(R_q)\times \mathrm{BC}_k(R_q)$ such that
\[
t\,s - s\,A \;=\; e \quad\text{in } \mathrm{BC}_k(R_q).
\]
We vectorize via $\mathrm{vec}(\cdot)$ and define
\[
B \;=\; \big(\,I_k\otimes t \;-\; A^\top\otimes I_k\,\big)\ \Big|\ \big(-I_{k^2}\big)\ \in R_q^{k^2\times 2k^2}.
\]
Let $\mu\in \mathrm{BC}_k(R_q)$ be the hashed/expanded image of the message (coefficients centered in $(-\tfrac{q}{2},\tfrac{q}{2}]$) and $\mu^\star\!=\mathrm{vec}(\mu)$.
Set
\[
\boxed{\quad
z_0 \;=\;
\begin{bmatrix}
\mathrm{vec}(s)\\[2pt]
\mathrm{vec}(e-\mu)
\end{bmatrix}
\quad}
\]
then $Bz_0=\mu^\star$. Indeed,
\[
Bz_0 \;=\; \underbrace{\big(I_k\!\otimes\! t - A^\top\!\otimes\! I_k\big)\mathrm{vec}(s) - \mathrm{vec}(e)}_{=\,0}
\;+\;\mathrm{vec}(\mu)
\;=\;\mu^\star,
\]
where the cancellation follows from $ts-sA=e$ after vectorization. \emph{Note:} center the coefficients of $\mu$ modulo $q$ (hence those of $e-\mu$) to control the norm.

\vspace{1ex}
% --- Point 2: Sampling in the kernel via (s,e)
\paragraph{Step 2: Sampling in \texorpdfstring{$\ker B$} using $(s,e)$.}

The relation $ts - sA = e$ implies, for any $V\in \mathrm{BC}_k(R_q)$,
\[
t(sV) - (sV)A \;=\; eV.
\]
Vectorizing,
\[
B\begin{bmatrix}\mathrm{vec}(sV)\\[2pt]\mathrm{vec}(eV)\end{bmatrix} \;=\; 0,
\]
so the family $\big\{(sV,eV):V\in \mathrm{BC}_k(R_q)\big\}$ yields vectors in the kernel $L=\ker B$.
We then obtain a signature by \emph{Gaussian shifting}:
\[
z \;=\; z_0 \;+\; y, \qquad
y \;=\;
\begin{bmatrix}\mathrm{vec}(sV)\\ \mathrm{vec}(eV)\end{bmatrix}
\in L,
\]
where $V$ is sampled “small” (e.g., $V\leftarrow D_{\sigma_V}$, a coefficient-wise centered discrete Gaussian).
With a standard rejection test (e.g., $\|z\|\le \rho$ for a suitable bound $\rho$), we obtain $Bz=B(z_0+y)=\mu^\star$ and a controlled norm.
\emph{Implementation.} The products $sV$ and $eV$ are block-wise polynomial convolutions, which can be accelerated via NTT “per slots”.

% --- TL;DR — Key formula
% \paragraph{ Key formula.}

% Let $B=\big(I_k\otimes t - A^\top\otimes I_k\ \big)\ \Big|\ \big(-I_{k^2}\big)$ and $\mu^\star=\mathrm{vec}(\mu)$.
% With $(s,e)$ such that $ts-sA=e$ in $\mathrm{BC}_k(R_q)$, set
% \[
% \boxed{\;
% z_0
% =
% \begin{bmatrix}
% \mathrm{vec}(s)\\[2pt]
% \mathrm{vec}(e-\mu)
% \end{bmatrix}
% \;}
% \qquad\text{(coefficients centered mod $q$),}
% \]
% so that $Bz_0=\mu^\star$.

% Moreover, for any $V\in\mathrm{BC}_k(R_q)$,
% \[
% y \;=\;
% \begin{bmatrix}
% \mathrm{vec}(sV)\\[2pt]
% \mathrm{vec}(eV)
% \end{bmatrix}
% \in \ker B,
% \]
% and the signature vector is obtained by Gaussian shifting:
% \[
% \boxed{\; z \;=\; z_0 + y \;}
% \quad\Rightarrow\quad
% Bz \;=\; B(z_0+y) \;=\; \mu^\star.
% \]
% \emph{Sampling:} choose $V$ “small” (e.g., coefficient-wise discrete Gaussian), and apply a standard rejection test $\|z\|\le \rho$.



% \noindent\textbf{Step 1: Key Generation Correctness.}
% From the key generation algorithm, we have:
% \[
% t = (s A + e) s^{-1} \Rightarrow t s - s A = e
% \]
% Vectorizing this equation gives:
% \[
% (I_k \otimes t - A^\top \otimes I_k) \cdot \text{vec}(s) - \text{vec}(e) = 0
% \]
% which is equivalent to:
% \[
% B \cdot \mathbf{y} = 0 \quad \text{where} \quad \mathbf{y} = \begin{bmatrix} \text{vec}(s) \\ \text{vec}(e) \end{bmatrix}
% \]

% \noindent\textbf{Step 2: Signature Validity.}
% During signing, we sample $\mathbf{z} \leftarrow D_{\mathcal{L} + \mathbf{z}_0, \sigma}$ where $\mathcal{L} = \ker(B)$ and $B \cdot \mathbf{z}_0 = \mu$. For any $\mathbf{z} \in \mathcal{L} + \mathbf{z}_0$, we have:
% \[
% B \cdot \mathbf{z} = B \cdot (\mathbf{z}_0 + \mathbf{y}) = B \cdot \mathbf{z}_0 + B \cdot \mathbf{y} = \mu + 0 = \mu
% \]
% where $\mathbf{y} \in \mathcal{L}$.

\noindent\textbf{Step 3: Norm Bound.}
The rejection step ensures $\|\mathbf{z}\| \leq \rho$ with probability $1 - \epsilon$. The parameter $\rho$ is chosen as:
\[
\rho = \lfloor 1.1 \cdot \sigma \sqrt{2k^2 n} \rceil
\]
which guarantees negligible rejection probability for Gaussian distributions.
% --- Choosing the rejection bound rho
\paragraph{Parameterizing the rejection bound $\rho$.}

Let $d=\dim(z)=2\,k^2\,n$ be the ambient dimension (since $z=[\mathrm{vec}(s);\mathrm{vec}(e)]$
with $k^2$ polynomials per block and degree-$n{-}1$ coefficients). We assume
signatures are sampled from a discrete Gaussian on the affine coset $L+z_0$
with spherical covariance. Fix a target per-signature failure probability $\varepsilon_{\mathrm{rej}}$
(e.g., $2^{-64}$ or $2^{-90}$). Then choose $\rho$ from the following tail bounds.

\medskip
\noindent\textbf{(A) If you use the \emph{statistics} convention} $X\sim\mathcal{N}(0,\sigma^2 I_d)$:\\
A $\chi^2$-tail yields, with probability $\ge 1-\varepsilon_{\mathrm{rej}}$,
\[
\|X\|_2 \;\le\;
\rho_2(\sigma,d,\varepsilon_{\mathrm{rej}})\;:=\;
\sigma\,
\sqrt{\,d \;+\; 2\sqrt{d\,\ln \tfrac{1}{\varepsilon_{\mathrm{rej}}}} \;+\; 2\ln \tfrac{1}{\varepsilon_{\mathrm{rej}}}}\,.
\]
A union bound gives an $\ell_\infty$-bound:
\[
\|X\|_\infty \;\le\;
\rho_\infty(\sigma,d,\varepsilon_{\mathrm{rej}})\;:=\;
\sigma\,\sqrt{\,2\ln \tfrac{2d}{\varepsilon_{\mathrm{rej}}}}\,.
\]

\medskip
\noindent\textbf{(B) If you use the \emph{GPV} convention} $D_{\,\cdot,s}$ with density $\propto e^{-\pi \|x\|^2/s^2}$:\\
Recall the conversion $\sigma=\tfrac{s}{\sqrt{2\pi}}$. The bounds become
\[
\|X\|_2 \;\le\;
\boxed{\;
\rho_2(s,d,\varepsilon_{\mathrm{rej}})\;=\;
\frac{s}{\sqrt{2\pi}}\,
\sqrt{\,d \;+\; 2\sqrt{d\,\ln \tfrac{1}{\varepsilon_{\mathrm{rej}}}} \;+\; 2\ln \tfrac{1}{\varepsilon_{\mathrm{rej}}}}\,,
\;}
\]
\[
\|X\|_\infty \;\le\;
\boxed{\;
\rho_\infty(s,d,\varepsilon_{\mathrm{rej}})\;=\;
s\,\sqrt{\,\frac{\ln \tfrac{2d}{\varepsilon_{\mathrm{rej}}}}{\pi}}\,.
\;}
\]

\medskip
\noindent\textbf{Recommended practice.}
\begin{itemize}\itemsep2pt
  \item Use the \emph{same convention} here as in your sampler.
  \item Pick a norm for the test (most works use $\ell_2$; some use $\ell_\infty$ for simpler side-channel envelopes) and set
  \[
    \rho \;=\; (1+\delta_\rho)\cdot
    \begin{cases}
      \rho_2(\cdot) & \text{if you test in }\ell_2,\\[2pt]
      \rho_\infty(\cdot) & \text{if you test in }\ell_\infty,
    \end{cases}
  \]
  with a small safety margin $\delta_\rho\in[0.05,0.15]$.
  \item Dimension: $d=2k^2 n$. Example: $k{=}2,n{=}256\Rightarrow d{=}2048$.
  \item Choose $\varepsilon_{\mathrm{rej}}$ so that the \emph{expected} acceptance is high
        (e.g., $\ge 0.99$) while keeping leakage negligible; typical values:
        $\varepsilon_{\mathrm{rej}}=2^{-64}$, $2^{-90}$ or $2^{-128}$.
  \item Ensure your Gaussian parameter satisfies the smoothing requirement
        (e.g., $s\ge \eta_{\varepsilon_{\mathrm{sm}}}(L)$ with negligible $\varepsilon_{\mathrm{sm}}$),
        then apply the bound above to $z\sim D_{L+z_0,s}$.
\end{itemize}

\medskip
\noindent\textbf{One-line TL;DR (for $\ell_2$):}
\[
\boxed{\quad
\rho \;=\; (1+\delta_\rho)\cdot
\begin{cases}
\sigma\,\sqrt{\,d + 2\sqrt{d\ln(1/\varepsilon)} + 2\ln(1/\varepsilon)} & \text{(stats conv.)},\\[4pt]
\frac{s}{\sqrt{2\pi}}\,\sqrt{\,d + 2\sqrt{d\ln(1/\varepsilon)} + 2\ln(1/\varepsilon)} & \text{(GPV conv.)}.
\end{cases}
\quad}
\]


\noindent\textbf{Step 4: Compression Preservation.}
The compression and decompression functions satisfy $\text{Decompress}(\text{Compress}(\mathbf{z})) = \mathbf{z}$ exactly, preserving the algebraic relationship.

Therefore, with overwhelming probability, a valid signature satisfies both the equation $B \cdot \mathbf{z} = \mu$ and the norm bound $\|\mathbf{z}\| \leq \rho$, leading to successful verification.
\end{proof}


\section*{Conclusion}
\label{sec:conclusion}

This journey through the landscape of lattice-based cryptography has led us to a novel generalization of the discrete logarithm problem—one that bridges the elegance of classical algebraic structures with the quantum-resistant security of Euclidean lattices. What began as a theoretical exploration has blossomed into a comprehensive framework with practical applications that could help secure our digital future.

At its heart, our work demonstrates that the rich mathematical tapestry of discrete logarithms need not be abandoned in the post-quantum era. By reimagining this classical problem through the lens of structured lattices, we've created something both familiar and new: a family of problems that maintains algebraic elegance while offering provable security against quantum attacks. The reduction to Module-SIS provides more than just a security guarantee—it creates a bridge between two seemingly different worlds of computational hardness. This connection suggests that our approach is not merely an isolated construction, but part of the broader mathematical landscape of lattice cryptography.

Beyond theoretical contributions, we've shown how these ideas translate into real cryptographic tools. The key exchange protocol allows two parties to establish secure communication using mathematical operations that are both efficient and intuitive. The encryption scheme and KEM demonstrate how our framework can be adapted to provide various levels of security, including the strong IND-CCA2 guarantee that modern applications require.

What makes these constructions particularly appealing is their balance between security and efficiency. The block-circulant structure enables compact representations and fast operations, while the algebraic foundation provides clear security arguments. This combination could make our schemes attractive for practical implementation in resource-constrained environments.

% \subsection*{Looking Forward}
The path we've opened invites further exploration in several exciting directions:

\begin{itemize}
    \item \textbf{Implementation optimization}: Turning these mathematical constructions into efficient software and hardware implementations
    \item \textbf{Parameter refinement}: Fine-tuning the security parameters based on more extensive cryptanalysis
    \item \textbf{New applications}: Exploring how our framework might support advanced cryptographic functionalities like digital signatures or advanced protocols
    \item \textbf{Hybrid approaches}: Combining our techniques with other post-quantum strategies for enhanced security
\end{itemize}

We envision a future where cryptographers continue to build upon this foundation, perhaps discovering new variants or applications we haven't yet imagined. The collaborative nature of cryptographic research means that our work is not an endpoint, but rather an invitation for others to join in building the secure infrastructure of tomorrow.

% \subsection*{Final Thoughts}

As quantum computing advances from theoretical possibility to practical reality, the need for quantum-resistant cryptography becomes increasingly urgent. Our contribution represents one more option in the growing toolkit of post-quantum solutions—one that we hope will be both mathematically satisfying and practically useful.

The beauty of cryptography lies in its dual nature: it is both a deep mathematical discipline and a practical engineering art. We believe our work honors both aspects, offering rigorous theoretical foundations while remaining grounded in practical applicability. As the cryptographic community continues its vital work of securing our digital world, we're excited to see where these ideas might lead.

% \section*{Use of Artificial Intelligence}
% The authors used the DeepSeekV2 and ChatGpt 5 language models  for paraphrasing certain paragraphs to improve their clarity. The authors supervised and proofread the generated content and take full responsibility for the published content.

\section*{Acknowledgements}

We acknowledge the assistance of the DeepSeek AI and ChatGPT models for paraphrasing certain paragraphs to improve their clarity. It is important to note that the authors are solely responsible for the research, analysis, and final written content of this paper.
\bibliographystyle{plain}
\bibliography{references}
\appendix
\section{Algebraic Foundations of Block-Circulant Matrices}
\label{app:block-circulant-algebra}

This appendix provides a comprehensive treatment of the algebraic structure of block-circulant matrices over the ring 
$R_q = \mathbb{Z}_q[x]/(x^n+1)$, which forms the mathematical foundation for our cryptographic constructions 
(see ~\cite{davis1979circulant,gray2006toeplitz,neudecker1990circulant}).

\subsection{Definition and Basic Properties}

\begin{definition}[Block-Circulant Matrix]
Let $k$ be a positive integer. A \emph{block-circulant matrix} $M \in \mathrm{BC}_k(R_q)$ is a $k \times k$ block matrix where each block is an element of $R_q$, satisfying the circulant property:
\[
M = 
\begin{bmatrix}
A_0 & A_1 & \cdots & A_{k-1} \\
A_{k-1} & A_0 & \cdots & A_{k-2} \\
\vdots & \vdots & \ddots & \vdots \\
A_1 & A_2 & \cdots & A_0
\end{bmatrix}
\]
for some $A_0, A_1, \ldots, A_{k-1} \in R_q$. The entire matrix is determined by its first block row $(A_0, A_1, \ldots, A_{k-1})$ 
\cite{davis1979circulant}.
\end{definition}

\begin{definition}[Cyclic Shift Matrix]
The fundamental building block is the $k \times k$ cyclic shift matrix:
\[
P = 
\begin{pmatrix}
0 & 1 & 0 & \cdots & 0 \\
0 & 0 & 1 & \cdots & 0 \\
\vdots & \vdots & \vdots & \ddots & \vdots \\
0 & 0 & 0 & \cdots & 1 \\
1 & 0 & 0 & \cdots & 0
\end{pmatrix}
\]
which satisfies $P^k = I_k$, the $k \times k$ identity matrix \cite{gray2006toeplitz}.
\end{definition}

\subsection{Polynomial Representation and Ring Isomorphism}

The key insight is that block-circulant matrices admit a natural polynomial representation \cite{neudecker1990circulant}.

\begin{theorem}[Polynomial Representation]
For any polynomial $b(x) = \sum_{i=0}^{k-1} b_i x^i \in R_q[x]$, the matrix $b(P) = \sum_{i=0}^{k-1} b_i P^i$ is block-circulant with first row $(b_0, b_1, \ldots, b_{k-1})$. Conversely, every block-circulant matrix arises uniquely in this way.
\end{theorem}

\begin{theorem}[Ring Isomorphism]
\label{thm:ring-iso}
The map
\[
\Phi: R_q[x]/(x^k-1) \to \mathrm{BC}_k(R_q), \quad \Phi([b(x)]) = b(P)
\]
is a well-defined ring isomorphism \cite{davis1979circulant}.
\end{theorem}

\begin{proof}
\emph{Well-defined:} If $b(x) \equiv c(x) \pmod{x^k-1}$, then $b(x) - c(x) = (x^k-1)q(x)$ for some $q(x) \in R_q[x]$. Evaluating at $P$ gives:
\[
b(P) - c(P) = (P^k - I)q(P) = 0
\]
since $P^k = I$. Thus $\Phi$ is well-defined.

\emph{Ring Homomorphism:} For addition and scalar multiplication, linearity is clear. For multiplication:
\[
\Phi([b][c]) = \Phi\left(\left[\sum_{t=0}^{k-1} \left(\sum_{i+j \equiv t \pmod{k}} b_i c_j\right) x^t\right]\right)
= \sum_{t=0}^{k-1} \left(\sum_{i+j \equiv t \pmod{k}} b_i c_j\right) P^t
\]
On the other hand:
\[
\Phi([b])\Phi([c]) = \left(\sum_{i=0}^{k-1} b_i P^i\right)\left(\sum_{j=0}^{k-1} c_j P^j\right)
= \sum_{i,j} b_i c_j P^{i+j} = \sum_{t=0}^{k-1} \left(\sum_{i+j \equiv t \pmod{k}} b_i c_j\right) P^t
\]
Thus $\Phi([b][c]) = \Phi([b])\Phi([c])$.

\emph{Bijectivity:} Surjectivity follows from the polynomial representation theorem. Injectivity follows because if $\Phi([b]) = 0$, then all coefficients $b_i = 0$.
\end{proof}

\subsection{Algebraic Structure and Properties}

\begin{corollary}[Commutativity]
\label{cor:commutativity}
The algebra $\mathrm{BC}_k(R_q)$ is commutative.
\end{corollary}

\begin{proof}
Since $R_q[x]/(x^k-1)$ is commutative (as $R_q$ is commutative and we quotient by a principal ideal) and $\Phi$ is a ring isomorphism, its image $\mathrm{BC}_k(R_q)$ is also commutative.
\end{proof}

\begin{corollary}[Closure Properties]
The set $\mathrm{BC}_k(R_q)$ is closed under:
\begin{itemize}
\item Addition and subtraction
\item Multiplication
\item Scalar multiplication by elements of $R_q$
\item Inversion (when the inverse exists)
\end{itemize}
Thus, $\mathrm{BC}_k(R_q)$ forms a commutative $R_q$-algebra.
\end{corollary}

\begin{theorem}[Characterization of Invertible Elements]
\label{thm:invertibility}
An element $C \in \mathrm{BC}_k(R_q)$ is invertible if and only if its corresponding polynomial $[b(x)] \in R_q[x]/(x^k-1)$ is a unit. Moreover, if $C^{-1}$ exists, then $C^{-1} \in \mathrm{BC}_k(R_q)$.
\end{theorem}

\begin{proof}
Since $\Phi$ is a ring isomorphism, it preserves units. If $[b(x)]$ is a unit with inverse $[c(x)]$, then $\Phi([c(x)])$ is the inverse of $C$. Conversely, if $C$ is invertible with inverse $D$, then $D = \Phi([c(x)])$ for some $[c(x)]$ (by surjectivity), and $[b(x)][c(x)] = [1]$ (by injectivity).
\end{proof}


\subsection{Compact Representation and Efficient Computation}

\begin{proposition}[Efficient Multiplication]
Multiplication in $\mathrm{BC}_k(R_q)$ can be performed in $O(kn\log n)$ time using the Number Theoretic Transform (NTT) \cite{cooley1965fft, nussbaumer1981fast}.
\end{proposition}

This allows representing a $k \times k$ block-circulant matrix using only $k$ elements of $R_q$ instead of $k^2$ elements.

\begin{proposition}[Efficient Multiplication]
Multiplication in $\mathrm{BC}_k(R_q)$ can be performed in $O(kn\log n)$ time using the Number Theoretic Transform (NTT).
\end{proposition}

\begin{proof}
Let $C = \Phi([b(x)])$ and $D = \Phi([c(x)])$. Then $CD = \Phi([b(x)c(x)])$. The product $b(x)c(x) \mod (x^k-1)$ can be computed via:
\begin{enumerate}
\item Apply length-$k$ NTT to the coefficient vectors of $b(x)$ and $c(x)$
\item Multiply pointwise in the NTT domain ($O(k)$ operations)
\item Apply inverse NTT
\end{enumerate}
Each NTT operation costs $O(kn\log n)$ when combined with the internal NTT structure of $R_q$.
\end{proof}

\subsection{Distribution of Small Elements}

This assumption is supported by empirical evidence in common cyclotomic rings and is crucial for the security reduction to Module-SIS 
\cite{micciancio2002lattice,lyubashevsky2010ideal,albrecht2017concrete}.
\begin{definition}[Distribution Extension]
Let $\chi$ be a distribution over $R_q$ that produces polynomials with small coefficients (e.g., centered binomial or discrete Gaussian). We extend $\chi$ to $\mathrm{BC}_k(R_q)$ by applying $\chi$ independently to each block of the matrix. Formally, to sample from $\chi$ over $\mathrm{BC}_k(R_q)$:
\begin{enumerate}
\item Sample $A_0, A_1, \ldots, A_{k-1} \leftarrow \chi$
\item Output the block-circulant matrix with first row $(A_0, A_1, \ldots, A_{k-1})$
\end{enumerate}
\end{definition}

\begin{assumption}[Density of Invertibles (Inv-BC)]
Let $\chi_s$ be a distribution of "small" elements over $\mathrm{BC}_k(R_q)$ (e.g., obtained by extending a small distribution $\chi$). We assume that the probability of sampling an invertible element is non-negligible:
\[
\Pr_{S \leftarrow \chi_s}[S \text{ is invertible in } \mathrm{BC}_k(R_q)] \geq c
\]
for some constant $c > 0$.
\end{assumption}

This assumption is supported by empirical evidence in common cyclotomic rings and is crucial for the security reduction to Module-SIS.

\subsection{Spectral Interpretation }

When $R_q$ contains a primitive $k$-th root of unity $\omega$ and supports a discrete Fourier transform, we obtain an alternative characterization.

\begin{theorem}[Spectral Decomposition]
If there exists a primitive $k$-th root of unity $\omega \in R_q$, then every $C \in \mathrm{BC}_k(R_q)$ can be diagonalized as:
\[
C = F^{-1} \cdot \mathrm{diag}(b(1), b(\omega), b(\omega^2), \ldots, b(\omega^{k-1})) \cdot F
\]
where $F$ is the $k \times k$ Fourier matrix over $R_q$ and $b(x)$ is the polynomial corresponding to $C$.
\end{theorem}

\begin{corollary}[Spectral Invertibility]
Under the above conditions, $C$ is invertible if and only if $b(\omega^j)$ is a unit in $R_q$ for all $j = 0, 1, \ldots, k-1$.
\end{corollary}

This spectral viewpoint provides additional intuition but is not essential for our cryptographic constructions, as we work directly with the polynomial representation.

% \subsection{Summary}

% The algebra $\mathrm{BC}_k(R_q)$ provides an elegant mathematical framework that combines:
% \begin{itemize}
% \item \emph{Algebraic structure}: Commutative ring properties enabling Diffie-Hellman-like protocols
% \item \emph{Computational efficiency}: Compact representation and fast operations via NTT
% \item \emph{Security foundations}: Reduction to well-studied lattice problems (Module-SIS)
% \item \emph{Practical utility}: Balanced trade-off between security and performance
% \end{itemize}

% These properties make $\mathrm{BC}_k(R_q)$ an ideal foundation for post-quantum cryptographic constructions that generalize the discrete logarithm problem to the lattice setting.
% \appendix
\section{Numerical Example of Vectorization and Compression for $k=3$}
\label{app:numerical-example}

Here we illustrate the complete vectorization and compression process described in Section~\ref{subsec:compression} with a small numerical example in dimension $k=3$ over the finite field $\mathbb{F}_7$.

\subsection{Choice of Matrices and Verification}
\label{subsec:numerical-matrices}

Consider the following circulant matrices over $\mathbb{F}_7$:

\[
S = \operatorname{circ}(1,2,0) =
\begin{pmatrix}
1 & 2 & 0 \\
0 & 1 & 2 \\
2 & 0 & 1
\end{pmatrix},
\quad
E = \operatorname{circ}(0,1,1) =
\begin{pmatrix}
0 & 1 & 1 \\
1 & 0 & 1 \\
1 & 1 & 0
\end{pmatrix},
\quad
A =
\begin{pmatrix}
1 & 0 & 3 \\
2 & 1 & 4 \\
0 & 5 & 6
\end{pmatrix}.
\]

We verify that $\det(S) = 2 \neq 0 \pmod{7}$, so $S$ is invertible. Let us compute $T$ such that $TS - SA = E$:

\[
T = (SA + E)S^{-1} =
\begin{pmatrix}
0 & 3 & 6 \\
3 & 5 & 0 \\
5 & 3 & 6
\end{pmatrix} \pmod{7}.
\]

Verification:
\[
TS =
\begin{pmatrix}
5 & 3 & 5 \\
3 & 4 & 3 \\
3 & 6 & 5
\end{pmatrix},
\quad
SA =
\begin{pmatrix}
5 & 2 & 4 \\
2 & 4 & 2 \\
2 & 5 & 5
\end{pmatrix},
\quad
TS - SA =
\begin{pmatrix}
0 & 1 & 1 \\
1 & 0 & 1 \\
1 & 1 & 0
\end{pmatrix} = E \pmod{7}.
\]

\subsection{Vectorization without Constraint}
\label{subsec:vectorization-no-constraint}

The vectorization operator stacks the columns:
\[
\operatorname{vec}(S) =
\begin{pmatrix}
1 \\ 0 \\ 2 \\ 2 \\ 1 \\ 0 \\ 0 \\ 2 \\ 1
\end{pmatrix},
\quad
\operatorname{vec}(E) =
\begin{pmatrix}
0 \\ 1 \\ 1 \\ 1 \\ 0 \\ 1 \\ 1 \\ 1 \\ 0
\end{pmatrix}.
\]

From Lemma~\ref{lem:linearization}, we have:
\[
M = I_3 \otimes T - A^\top \otimes I_3 \in \mathbb{F}_7^{9 \times 9},
\]
with
\[
I_3 \otimes T =
\begin{pmatrix}
T & 0 & 0 \\
0 & T & 0 \\
0 & 0 & T
\end{pmatrix},
\quad
A^\top \otimes I_3 =
\begin{pmatrix}
1I_3 & 2I_3 & 0I_3 \\
0I_3 & 1I_3 & 5I_3 \\
3I_3 & 4I_3 & 6I_3
\end{pmatrix}.
\]

A calculation yields:
\[
M =
\begin{pmatrix}
6 & 3 & 6 & 5 & 0 & 0 & 0 & 0 & 0 \\
3 & 4 & 0 & 0 & 5 & 0 & 0 & 0 & 0 \\
5 & 3 & 5 & 0 & 0 & 5 & 0 & 0 & 0 \\
0 & 0 & 0 & 6 & 3 & 6 & 2 & 0 & 0 \\
0 & 0 & 0 & 3 & 4 & 0 & 0 & 2 & 0 \\
0 & 0 & 0 & 5 & 3 & 5 & 0 & 0 & 2 \\
4 & 0 & 0 & 3 & 0 & 0 & 1 & 3 & 6 \\
0 & 4 & 0 & 0 & 3 & 0 & 3 & 6 & 0 \\
0 & 0 & 4 & 0 & 0 & 3 & 5 & 3 & 0
\end{pmatrix} \pmod{7}.
\]

We indeed verify that $M \operatorname{vec}(S) = \operatorname{vec}(E)$.

\subsection{Compression with Circulant Structure}
\label{subsec:compression-example}

Since matrices $S$ and $E$ are circulant, they are determined by their first rows:
\[
\mathbf{s} = (s_0, s_1, s_2)^\top = (1, 2, 0)^\top,
\quad
\mathbf{e} = (e_0, e_1, e_2)^\top = (0, 1, 1)^\top.
\]

The structure matrix $P_3$ for $k=3$ is:
\[
P_3 =
\begin{pmatrix}
1 & 0 & 0 \\
0 & 0 & 1 \\
0 & 1 & 0 \\
0 & 1 & 0 \\
1 & 0 & 0 \\
0 & 0 & 1 \\
0 & 0 & 1 \\
0 & 1 & 0 \\
1 & 0 & 0
\end{pmatrix}.
\]

We indeed have $\operatorname{vec}(S) = P_3 \mathbf{s}$ and $\operatorname{vec}(E) = P_3 \mathbf{e}$.

The compressed matrix is:
\[
N = [M P_3 \mid -P_3] \in \mathbb{F}_7^{9 \times 6}.
\]

Explicit calculation:
\[
N =
\begin{pmatrix}
6 & 4 & 3 & 6 & 0 & 0 \\
1 & 0 & 4 & 0 & 0 & 6 \\
5 & 5 & 1 & 0 & 6 & 0 \\
3 & 6 & 1 & 0 & 6 & 0 \\
4 & 5 & 0 & 6 & 0 & 0 \\
5 & 5 & 5 & 0 & 0 & 6 \\
3 & 6 & 1 & 0 & 0 & 6 \\
3 & 6 & 0 & 0 & 6 & 0 \\
0 & 0 & 1 & 6 & 0 & 0
\end{pmatrix} \pmod{7}.
\]

The compressed unknown vector is:
\[
x_{\text{circ}} =
\begin{pmatrix}
\mathbf{s} \\ \mathbf{e}
\end{pmatrix}
=
\begin{pmatrix}
1 \\ 2 \\ 0 \\ 0 \\ 1 \\ 1
\end{pmatrix}.
\]

We verify that $N x_{\text{circ}} = 0$ modulo 7, confirming that the compressed solution satisfies the linear system.

\subsection{Dimensionality Reduction Analysis}
\label{subsec:dimension-analysis}

Without structural constraints, we would have:
\begin{itemize}
    \item Unknowns: 18 (9 for $S$, 9 for $E$)
    \item Equations: 9 from $TS - SA = E$
\end{itemize}

With the circulant structure, we obtain:
\begin{itemize}
    \item Unknowns: 6 (3 for $\mathbf{s}$, 3 for $\mathbf{e}$)
    \item Equations: 9 (of which only 5 are linearly independent in this example)
\end{itemize}

The compression gain is therefore a factor of $k = 3$ in the number of unknowns, illustrating the effectiveness of exploiting the circulant structure in the DLPL-S to Module-SIS reduction.

\subsection{Graphical Representation of the Process}
\label{subsec:visual-process}

The complete process can be visualized as follows:

\begin{center}
\begin{tikzpicture}[node distance=1.5cm]
\node[box] (eq) {Equation: $TS - SA = E$};
\node[box, below=of eq] (vec) {Vectorization: $M \operatorname{vec}(S) = \operatorname{vec}(E)$};
\node[box, below=of vec] (comp) {Compression: $N x_{\text{circ}} = 0$};
\node[box, below=of comp] (solve) {Solution: $\mathbf{s} = (1,2,0)^\top, \mathbf{e} = (0,1,1)^\top$};

\draw[arrow] (eq) -- (vec);
\draw[arrow] (vec) -- (comp);
\draw[arrow] (comp) -- (solve);
\end{tikzpicture}
\end{center}

This example concretely demonstrates how the algebraic structure of circulant matrices allows for a significant reduction in the problem's dimension while preserving the information necessary for its solution.
\end{document}